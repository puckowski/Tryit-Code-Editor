"use strict";function tokenize(e){const n=[];let t=0;const r=e=>/[a-zA-Z_]/.test(e),o=e=>/[0-9]/.test(e),i=e=>r(e)||o(e);for(;t<e.length;){let p=e[t];if(" "===p||"\t"===p||"\n"===p||"\r"===p){t++;continue}if("/"===p&&"/"===e[t+1]){for(;t<e.length&&"\n"!==e[t];)t++;continue}if('"'===p||"'"===p){const r=p;let o=t++,i="";for(;t<e.length&&e[t]!==r;)if("\\"===e[t]){if(t+1>=e.length)break;const n=e[t+1];i+="n"===n?"\n":"r"===n?"\r":"t"===n?"\t":"b"===n?"\b":"f"===n?"\f":"v"===n?"\v":"\\"===n?"\\":'"'===n?'"':"'"===n?"'":n,t+=2}else i+=e[t++];if(e[t]!==r)throw new Error("Unterminated string literal at "+o);t++,n.push({type:"string",value:i,pos:o});continue}if(o(p)){let r=t,i="",p=!1;for(;t<e.length&&(o(e[t])||"."===e[t]);){if("."===e[t]){if(p)break;p=!0}i+=e[t++]}p||"n"!==e[t]?n.push({type:"number",value:i,pos:r}):(t++,n.push({type:"bigint",value:i+"n",pos:r}));continue}if(r(p)){let r=t,o="";for(;t<e.length&&i(e[t]);)o+=e[t++];const p=new Set(["type","function","export","let","const","return","if","else","while","for","switch","case","default","break","try","catch","finally","class","new","async","await"]);n.push({type:p.has(o)?"keyword":"identifier",value:o,pos:r});continue}const u=e.substr(t,2);if(new Set(["==","!=","<=",">=","&&","||","=>","++","--"]).has(u)){n.push({type:"punct",value:u,pos:t}),t+=2;continue}if(!["{","}","(",")",";","+","-","*","/","=",",",":",".","<",">","[","]","?"].includes(p))throw new Error("Unexpected character: '"+p+"' at position "+t);n.push({type:"punct",value:p,pos:t}),t++}return n}const tokenizeTS=tokenize;function Program(e){return{kind:"Program",body:e}}function TypeDecl(e,n,t){return{kind:"TypeDecl",name:e,type:n,pos:t}}function VarDecl(e,n,t,r){return{kind:"VarDecl",name:e,type:n,init:t,pos:r}}function ConstDecl(e,n,t,r){return{kind:"ConstDecl",name:e,type:n,init:t,pos:r}}function FuncDecl(e,n,t,r,o,i=!1){return{kind:"FuncDecl",name:e,params:n,returnType:t,body:r,pos:o,isAsync:i}}function Param(e,n,t){return{kind:"Param",name:e,type:n,pos:t}}function Block(e,n){return{kind:"Block",statements:e,pos:n}}function ReturnStmt(e,n){return{kind:"ReturnStmt",expr:e,pos:n}}function ExprStmt(e,n){return{kind:"ExprStmt",expr:e,pos:n}}function ForStmt(e,n,t,r,o){return{kind:"ForStmt",init:e,test:n,update:t,body:r,pos:o}}function ForOfStmt(e,n,t,r){return{kind:"ForOfStmt",left:e,right:n,body:t,pos:r}}function ForInStmt(e,n,t,r){return{kind:"ForInStmt",left:e,right:n,body:t,pos:r}}function SwitchStmt(e,n,t){return{kind:"SwitchStmt",discriminant:e,cases:n,pos:t}}function CaseClause(e,n,t){return{kind:"CaseClause",test:e,consequent:n,pos:t}}function BreakStmt(e){return{kind:"BreakStmt",pos:e}}function TypeRef(e,n){return{kind:"TypeRef",name:e,pos:n}}function ObjectType(e,n){return{kind:"ObjectType",properties:e,pos:n}}function TypeProperty(e,n,t){return{kind:"TypeProperty",name:e,type:n,pos:t}}function ArrayType(e,n){return{kind:"ArrayType",element:e,pos:n}}function ExportDecl(e,n){return{kind:"ExportDecl",decl:e,pos:n}}function Identifier(e,n){return{kind:"Identifier",name:e,pos:n}}function NumberLiteral(e,n){return{kind:"NumberLiteral",value:e,pos:n}}function BigIntLiteral(e,n){return{kind:"BigIntLiteral",value:e,pos:n}}function StringLiteral(e,n){return{kind:"StringLiteral",value:e,pos:n}}function BoolLiteral(e,n){return{kind:"BoolLiteral",value:e,pos:n}}function BinaryExpr(e,n,t,r){return{kind:"BinaryExpr",op:e,left:n,right:t,pos:r}}function ConditionalExpr(e,n,t,r){return{kind:"ConditionalExpr",cond:e,thenExpr:n,elseExpr:t,pos:r}}function CallExpr(e,n,t){return{kind:"CallExpr",callee:e,args:n,pos:t}}function MemberExpr(e,n,t){return{kind:"MemberExpr",object:e,property:n,pos:t}}function ArrayLiteral(e,n){return{kind:"ArrayLiteral",elements:e,pos:n}}function IndexExpr(e,n,t){return{kind:"IndexExpr",object:e,index:n,pos:t}}function ArrowFunction(e,n,t,r=!1){return{kind:"ArrowFunction",params:e,body:n,pos:t,isAsync:r}}function AwaitExpr(e,n){return{kind:"AwaitExpr",argument:e,pos:n}}function UpdateExpr(e,n,t,r){return{kind:"UpdateExpr",argument:e,operator:n,prefix:t,pos:r}}function ObjectLiteral(e,n){return{kind:"ObjectLiteral",properties:e,pos:n}}function ObjectLiteralProperty(e,n,t){return{kind:"ObjectLiteralProperty",name:e,value:n,pos:t}}function FunctionExpr(e,n,t,r,o,i=!1){return{kind:"FunctionExpr",name:e,params:n,returnType:t,body:r,pos:o,isAsync:i}}function ClassDecl(e,n,t){return{kind:"ClassDecl",name:e,methods:n,pos:t}}function MethodDecl(e,n,t,r,o){return{kind:"MethodDecl",name:e,params:n,body:t,pos:r,isConstructor:o}}function NewExpr(e,n,t){return{kind:"NewExpr",callee:e,args:n,pos:t}}function parse(e){let n=0;function t(t=0){return e[n+t]||{type:"eof",value:"",pos:e.length}}function r(e,r){const o=t();if(e&&o.type!==e)throw new Error(`Expected token type ${e}, got ${o.type} at ${o.pos}`);if(r&&o.value!==r)throw new Error(`Expected '${r}', got '${o.value}' at ${o.pos}`);return n++,o}function o(e,r){const o=t();return!(o.type!==e||r&&o.value!==r)&&(n++,!0)}function i(){const e=t();if("identifier"===e.type||"keyword"===e.type)return n++,e;throw new Error(`Expected token type identifier, got ${e.type} at ${e.pos}`)}function p(){const e=t();return"punct"===e.type&&"{"===e.value?function(){const e=r("punct","{"),n=[];for(;"punct"!==t().type||"}"!==t().value;){const e=r("identifier");r("punct",":");const o=p();if(n.push(TypeProperty(e.value,o,e.pos)),"punct"!==t().type||","!==t().value)break;r("punct",",")}return r("punct","}"),ObjectType(n,e.pos)}():u()}function u(){const e=t();if("identifier"===e.type){r("identifier");let n=TypeRef(e.value,e.pos);for(;"punct"===t().type&&"["===t().value;){const e=r("punct","[");r("punct","]"),n=ArrayType(n,e.pos)}return n}throw new Error("Expected type name at "+e.pos)}function a(){const e=t();if("keyword"===e.type&&"export"===e.value){const e=r("keyword","export");return ExportDecl(a(),e.pos)}if("keyword"===e.type&&"type"===e.value)return function(){r("keyword","type");const e=r("identifier");r("punct","=");const n=p();return r("punct",";"),TypeDecl(e.value,n,e.pos)}();if("keyword"===e.type&&("function"===e.value||"async"===e.value&&"keyword"===t(1).type&&"function"===t(1).value))return function(){let e=!1;"keyword"===t().type&&"async"===t().value&&(r("keyword","async"),e=!0);r("keyword","function");const n=r("identifier");r("punct","(");const i=[];if(!o("punct",")")){do{const e=r("identifier");let n=null;"punct"===t().type&&":"===t().value&&(r("punct",":"),n=u()),i.push(Param(e.value,n,e.pos))}while(o("punct",","));r("punct",")")}let p=null;"punct"===t().type&&":"===t().value&&(r("punct",":"),p=u());const a=c();return FuncDecl(n.value,i,p,a,n.pos,e)}();if("keyword"===e.type&&"let"===e.value)return function(){r("keyword","let");const e=r("identifier");let n=null;"punct"===t().type&&":"===t().value&&(r("punct",":"),n=u());let o=null;"punct"===t().type&&"="===t().value&&(r("punct","="),o=s());return r("punct",";"),VarDecl(e.value,n,o,e.pos)}();if("keyword"===e.type&&"const"===e.value)return function(){r("keyword","const");const e=r("identifier");let n=null;"punct"===t().type&&":"===t().value&&(r("punct",":"),n=u());if("punct"===t().type&&"="===t().value){r("punct","=");const t=s();return r("punct",";"),ConstDecl(e.value,n,t,e.pos)}throw new Error(`Const '${e.value}' must have an initializer at ${e.pos}`)}();if("keyword"===e.type&&"if"===e.value)return function(){const e=r("keyword","if");r("punct","(");const n=s();r("punct",")");const o=c();let i=null;"keyword"===t().type&&"else"===t().value&&(r("keyword","else"),i=c());return{kind:"IfStmt",cond:n,thenBlock:o,elseBlock:i,pos:e.pos}}();if("keyword"===e.type&&"while"===e.value)return function(){const e=r("keyword","while");r("punct","(");const n=s();r("punct",")");const t=c();return{kind:"WhileStmt",cond:n,body:t,pos:e.pos}}();if("keyword"===e.type&&"for"===e.value)return function(){const e=r("keyword","for");if(r("punct","("),"keyword"===t().type&&("let"===t().value||"const"===t().value)){const n=t().value;r("keyword");const o=r("identifier");let i=null;if("punct"===t().type&&":"===t().value&&(r("punct",":"),i=u()),"identifier"===t().type&&("of"===t().value||"in"===t().value)){const p=t().value;r("identifier");const u=s();r("punct",")");const a=c(),l={declKind:n,name:o.value,typeAnn:i,pos:o.pos};return"of"===p?ForOfStmt(l,u,a,e.pos):ForInStmt(l,u,a,e.pos)}let p=null;"punct"===t().type&&"="===t().value&&(r("punct","="),p=s());const a="let"===n?VarDecl(o.value,i,p,o.pos):ConstDecl(o.value,i,p,o.pos);r("punct",";");const l="punct"===t().type&&";"===t().value?null:s();r("punct",";");const y="punct"===t().type&&")"===t().value?null:s();r("punct",")");return ForStmt(a,l,y,c(),e.pos)}let n=null;if("punct"!==t().type||";"!==t().value){const e=s();n=ExprStmt(e,e.pos)}r("punct",";");const o="punct"===t().type&&";"===t().value?null:s();r("punct",";");const i="punct"===t().type&&")"===t().value?null:s();r("punct",")");const p=c();return ForStmt(n,o,i,p,e.pos)}();if("keyword"===e.type&&"class"===e.value)return function(){const e=r("keyword","class"),n=r("identifier"),i=[];r("punct","{");for(;"punct"!==t().type||"}"!==t().value;){const e=r("identifier"),n="constructor"===e.value;r("punct","(");const p=[];if("punct"!==t().type||")"!==t().value)do{const e=r("identifier");let n=null;"punct"===t().type&&":"===t().value&&(r("punct",":"),n=u()),p.push(Param(e.value,n,e.pos))}while(o("punct",","));r("punct",")");const a=c();i.push(MethodDecl(e.value,p,a,e.pos,n))}return r("punct","}"),ClassDecl(n.value,i,e.pos)}();if("keyword"===e.type&&"try"===e.value)return function(){const e=r("keyword","try"),n=c();let o=null,i=null;if("keyword"===t().type&&"catch"===t().value){r("keyword","catch"),r("punct","(");const e=r("identifier");r("punct",")");const n=c();o={name:e.value,block:n,pos:e.pos}}"keyword"===t().type&&"finally"===t().value&&(r("keyword","finally"),i=c());return{kind:"TryStmt",tryBlock:n,catchClause:o,finallyBlock:i,pos:e.pos}}();if("keyword"===e.type&&"switch"===e.value)return function(){const e=r("keyword","switch");r("punct","(");const n=s();r("punct",")");const o=[];r("punct","{");for(;"punct"!==t().type||"}"!==t().value;){if("keyword"===t().type&&"case"===t().value){const e=r("keyword","case"),n=s();r("punct",":");const i=[];for(;("keyword"!==t().type||"case"!==t().value&&"default"!==t().value)&&("punct"!==t().type||"}"!==t().value);)i.push(a());o.push(CaseClause(n,i,e.pos));continue}if("keyword"===t().type&&"default"===t().value){const e=r("keyword","default");r("punct",":");const n=[];for(;("keyword"!==t().type||"case"!==t().value&&"default"!==t().value)&&("punct"!==t().type||"}"!==t().value);)n.push(a());o.push(CaseClause(null,n,e.pos));continue}throw new Error("Unexpected token in switch body: "+JSON.stringify(t()))}return r("punct","}"),SwitchStmt(n,o,e.pos)}();if("keyword"===e.type&&"break"===e.value){const e=r("keyword","break");r("punct",";");return BreakStmt(e.pos)}if("keyword"===e.type&&"return"===e.value)return function(){const e=r("keyword","return");if("punct"===t().type&&";"===t().value)return r("punct",";"),ReturnStmt(null,e.pos);const n=s();return r("punct",";"),ReturnStmt(n,e.pos)}();return ExprStmt(s(),r("punct",";").pos)}function c(){const e=r("punct","{"),n=[];for(;"punct"!==t().type||"}"!==t().value;)n.push(a());return r("punct","}"),Block(n,e.pos)}function s(){return y()}function l(){let e=function(){let e=f();for(;;){const r=t();if("punct"!==r.type||"||"!==r.value)break;{n++;const t=f();e=BinaryExpr(r.value,e,t,r.pos)}}return e}();const o=t();if("punct"===o.type&&"?"===o.value){n++;const t=y();r("punct",":");return ConditionalExpr(e,t,y(),o.pos)}return e}function y(){let e=l();const r=t();if("punct"===r.type&&"="===r.value){n++;e=BinaryExpr("=",e,y(),r.pos)}return e}function f(){let e=d();for(;;){const r=t();if("punct"!==r.type||"&&"!==r.value)break;{n++;const t=d();e=BinaryExpr(r.value,e,t,r.pos)}}return e}function d(){let e=m();for(;;){const r=t();if("punct"!==r.type||"=="!==r.value&&"!="!==r.value)break;{n++;const t=m();e=BinaryExpr(r.value,e,t,r.pos)}}return e}function m(){let e=k();for(;;){const r=t();if("punct"!==r.type||"<"!==r.value&&">"!==r.value&&"<="!==r.value&&">="!==r.value)break;{n++;const t=k();e=BinaryExpr(r.value,e,t,r.pos)}}return e}function k(){let e=v();for(;;){const r=t();if("punct"!==r.type||"+"!==r.value&&"-"!==r.value)break;{n++;const t=v();e=BinaryExpr(r.value,e,t,r.pos)}}return e}function v(){let e=g();for(;;){const r=t();if("punct"!==r.type||"*"!==r.value&&"/"!==r.value)break;{n++;const t=g();e=BinaryExpr(r.value,e,t,r.pos)}}return e}function g(){if("keyword"===t().type&&"new"===t().value){const e=r("keyword","new");let n=null;if("identifier"!==t().type)throw new Error("Expected identifier after 'new' at "+e.pos);{const e=r("identifier");n=Identifier(e.value,e.pos)}r("punct","(");const p=[];if("punct"!==t().type||")"!==t().value)do{p.push(s())}while(o("punct",","));r("punct",")");let u=NewExpr(n,p,e.pos);for(;;){const e=t();if("punct"===e.type&&"."===e.value){r("punct",".");const e=i();u=MemberExpr(u,e.value,e.pos)}else if("punct"===e.type&&"["===e.value){const e=r("punct","["),n=s();r("punct","]"),u=IndexExpr(u,n,e.pos)}else if("punct"===e.type&&"("===e.value){const e=r("punct","("),n=[];if("punct"!==t().type||")"!==t().value)do{n.push(s())}while(o("punct",","));r("punct",")"),u=CallExpr(u,n,e.pos)}else{if("punct"!==e.type||"++"!==e.value&&"--"!==e.value)break;r("punct",e.value),u=UpdateExpr(u,e.value,!1,e.pos)}}return u}let p=function(){const p=t();if("keyword"===p.type&&"await"===p.value){const a=r("keyword","await");return AwaitExpr(s(),a.pos)}if("keyword"===p.type&&"async"===p.value){if("identifier"===t(1).type&&"punct"===t(2).type&&"=>"===t(2).value){const l=r("keyword","async"),y=r("identifier");let f;return r("punct","=>"),f="punct"===t().type&&"{"===t().value?c():s(),ArrowFunction([y.value],f,l.pos,!0)}if("punct"===t(1).type&&"("===t(1).value){function d(n){let t=n+1;const r=e[n+1];if(!r||"punct"!==r.type||"("!==r.value)return!1;if(e[t]&&"punct"===e[t].type&&")"===e[t].value)return e[t+1]&&"punct"===e[t+1].type&&"=>"===e[t+1].value;for(;;){const n=e[t];if(!n)return!1;if("identifier"===n.type){if(t++,e[t]&&"punct"===e[t].type&&","===e[t].value){t++;continue}return!(!e[t]||"punct"!==e[t].type||")"!==e[t].value)&&(e[t+1]&&"punct"===e[t+1].type&&"=>"===e[t+1].value)}return!1}}if(d(n)){const m=r("keyword","async"),k=(r("punct","("),[]);if("punct"!==t().type||")"!==t().value)do{const g=r("identifier");k.push(g.value)}while(o("punct",","));let v;return r("punct",")"),r("punct","=>"),v="punct"===t().type&&"{"===t().value?c():s(),ArrowFunction(k,v,m.pos,!0)}}if("keyword"===p.type&&"async"===p.value&&"keyword"===t(1).type&&"function"===t(1).value){const b=r("keyword","async");r("keyword","function");let T=null;if("identifier"===t().type){T=r("identifier").value}r("punct","(");const h=[];if("punct"!==t().type||")"!==t().value)do{const $=r("identifier");let x=null;"punct"===t().type&&":"===t().value&&(r("punct",":"),x=u()),h.push(Param($.value,x,$.pos))}while(o("punct",","));r("punct",")");let w=null;"punct"===t().type&&":"===t().value&&(r("punct",":"),w=u());return FunctionExpr(T,h,w,c(),b.pos,!0)}if("keyword"===t(1).type&&"function"===t(1).value){r("keyword","async");const S=r("keyword","function");let E=null;if("identifier"===t().type){E=r("identifier").value}r("punct","(");const C=[];if("punct"!==t().type||")"!==t().value)do{const j=r("identifier");let A=null;"punct"===t().type&&":"===t().value&&(r("punct",":"),A=u()),C.push(Param(j.value,A,j.pos))}while(o("punct",","));r("punct",")");let B=null;"punct"===t().type&&":"===t().value&&(r("punct",":"),B=u());return FunctionExpr(E,C,B,c(),S.pos,!0)}}if("keyword"===p.type&&"function"===p.value){const F=r("keyword","function");let D=null;if("identifier"===t().type){D=r("identifier").value}r("punct","(");const L=[];if(!o("punct",")")){do{const O=r("identifier");let V=null;"punct"===t().type&&":"===t().value&&(r("punct",":"),V=u()),L.push(Param(O.value,V,O.pos))}while(o("punct",","));r("punct",")")}let I=null;"punct"===t().type&&":"===t().value&&(r("punct",":"),I=u());return FunctionExpr(D,L,I,c(),F.pos,!1)}if("bigint"===p.type)return r("bigint"),BigIntLiteral(p.value,p.pos);if("number"===p.type)return r("number"),NumberLiteral(Number(p.value),p.pos);if("string"===p.type)return r("string"),StringLiteral(p.value,p.pos);if("punct"===p.type&&"["===p.value){const P=r("punct","["),M=[];if("punct"!==t().type||"]"!==t().value)do{M.push(s())}while(o("punct",","));return r("punct","]"),ArrayLiteral(M,P.pos)}if("punct"===p.type&&"{"===p.value){const N=r("punct","{"),U=[];if("punct"!==t().type||"}"!==t().value)for(;;){const R="identifier"===t().type||"keyword"===t().type?i():r("identifier");r("punct",":");const q=s();if(U.push(ObjectLiteralProperty(R.value,q,R.pos)),"punct"!==t().type||","!==t().value)break;r("punct",",")}return r("punct","}"),ObjectLiteral(U,N.pos)}if("identifier"===p.type&&"punct"===t(1).type&&"=>"===t(1).value){const z=r("identifier");let J;return r("punct","=>"),J="punct"===t().type&&"{"===t().value?c():s(),ArrowFunction([z.value],J,z.pos)}if("identifier"===p.type)return"true"===p.value||"false"===p.value?(r("identifier"),BoolLiteral("true"===p.value,p.pos)):(r("identifier"),Identifier(p.value,p.pos));if("punct"===p.type&&"("===p.value){function K(){let r=n+1;if("punct"===t(1).type&&")"===t(1).value)return"punct"===t(2).type&&"=>"===t(2).value;for(;;){const n=e[r];if(!n)return!1;if("identifier"===n.type){if(r++,e[r]&&"punct"===e[r].type&&","===e[r].value){r++;continue}return!(!e[r]||"punct"!==e[r].type||")"!==e[r].value)&&(e[r+1]&&"punct"===e[r+1].type&&"=>"===e[r+1].value)}return!1}}if(K()){const Z=r("punct","("),_=[];if("punct"!==t().type||")"!==t().value)do{const H=r("identifier");_.push(H.value)}while(o("punct",","));let G;return r("punct",")"),r("punct","=>"),G="punct"===t().type&&"{"===t().value?c():s(),ArrowFunction(_,G,Z.pos)}r("punct","(");const W=s();return r("punct",")"),W}throw new Error("Unexpected token in expression: "+JSON.stringify(p))}();for(;;){const e=t();if("punct"===e.type&&"."===e.value){r("punct",".");const e="identifier"===t().type||"keyword"===t().type?i():r("identifier");p=MemberExpr(p,e.value,e.pos)}else if("punct"===e.type&&"["===e.value){const e=r("punct","["),n=s();r("punct","]"),p=IndexExpr(p,n,e.pos)}else if("punct"===e.type&&"("===e.value){const e=r("punct","("),n=[];if("punct"!==t().type||")"!==t().value)do{n.push(s())}while(o("punct",","));r("punct",")"),p=CallExpr(p,n,e.pos)}else{if("punct"!==e.type||"++"!==e.value&&"--"!==e.value)break;r("punct",e.value),p=UpdateExpr(p,e.value,!1,e.pos)}}return p}const b=[];for(;"eof"!==t().type;)b.push(a());return Program(b)}function anyType(){return{kind:"any"}}function primitiveType(e){return"any"===e?anyType():["number","string","boolean","void","bigint","null","undefined","symbol"].includes(e)?{kind:e}:null}function functionType(e,n){return{kind:"function",params:e,returnType:n}}function objectTypeFromAst(e,n,t){const r=new Map;for(const o of e.properties){const e=t(o.type,n);r.set(o.name,e)}return{kind:"object",properties:r}}function typeToString(e){if(!e)return"unknown";if("any"===e.kind)return"any";if("function"===e.kind)return`(${e.params.map(typeToString).join(", ")}) => ${typeToString(e.returnType)}`;if("object"===e.kind){const n=[];for(const[t,r]of e.properties.entries())n.push(`${t}: ${typeToString(r)}`);return`{ ${n.join("; ")} }`}return"array"===e.kind?`${typeToString(e.element)}[]`:e.kind}class Env{constructor(e=null){this.parent=e,this.types=new Map,this.values=new Map}defineType(e,n){this.types.set(e,n)}lookupType(e){return this.types.has(e)?this.types.get(e):this.parent?this.parent.lookupType(e):null}defineValue(e,n){this.values.set(e,n)}lookupValue(e){return this.values.has(e)?this.values.get(e):this.parent?this.parent.lookupValue(e):null}}function buildPosToLineMap(e){const n=[0];for(let t=0;t<e.length;t++)"\n"===e[t]&&n.push(t+1);return function(e){if("number"!=typeof e||e<0)return null;let t=1;for(let r=0;r<n.length&&n[r]<=e;r++)t=r+1;return t}}function typeCheck(e,n){const t=[],r=new Env;buildPosToLineMap(n);function o(e,n){t.push({msg:e,pos:n&&"number"==typeof n.pos?n.pos:0})}function i(e,n){switch(e.kind){case"TypeRef":{const t=primitiveType(e.name);if(t)return t;const r=n.lookupType(e.name);return r||(o(`Unknown type '${e.name}'`,e),primitiveType("void"))}case"ArrayType":return{kind:"array",element:i(e.element,n)};case"ObjectType":return objectTypeFromAst(e,n,i);default:return o("Unknown type expression kind: "+e.kind,e),primitiveType("void")}}function p(e,n,t){switch(e.kind){case"ExportDecl":p(e.decl,n,t);break;case"TypeDecl":{const t=i(e.type,n);n.defineType(e.name,t);break}case"VarDecl":{let t=e.type?i(e.type,n):null,r=null;e.init&&(r=a(e.init,n)),t&&r&&!c(r,t)&&o(`Cannot assign type '${typeToString(r)}' to '${typeToString(t)}' (variable '${e.name}')`,e),!t&&r&&(t=r),t||(t=anyType()),n.defineValue(e.name,t);break}case"ConstDecl":{let t=e.type?i(e.type,n):null;if(!e.init){o(`Const '${e.name}' must have an initializer`,e),t=t||anyType(),n.defineValue(e.name,t);break}const r=a(e.init,n);t&&!c(r,t)&&o(`Cannot assign type '${typeToString(r)}' to '${typeToString(t)}' (const '${e.name}')`,e),t||(t=r||anyType()),n.defineValue(e.name,t);break}case"FuncDecl":{const t=e.params.map(e=>e.type?i(e.type,n):anyType()),r=e.returnType?i(e.returnType,n):anyType(),o=functionType(t,r);n.defineValue(e.name,o);const p=new Env(n);e.params.forEach((e,n)=>{p.defineValue(e.name,t[n])}),u(e.body,p,o);break}case"Block":u(e,n,t);break;case"ReturnStmt":{if(!t){o("Return statement not inside function",e);break}const r=t.returnType;if(null===e.expr)"void"!==r.kind&&o(`Return type mismatch: expected '${typeToString(r)}' but got 'void'`,e);else{const t=a(e.expr,n);c(t,r)||o(`Return type mismatch: expected '${typeToString(r)}' but got '${typeToString(t)}'`,e)}break}case"ExprStmt":a(e.expr,n);break;case"IfStmt":{const r=a(e.cond,n);"boolean"!==r.kind&&"any"!==r.kind&&o(`Condition in if must be boolean, got '${typeToString(r)}'`,e.cond),p(e.thenBlock,n,t),e.elseBlock&&p(e.elseBlock,n,t);break}case"WhileStmt":{const r=a(e.cond,n);"boolean"!==r.kind&&"any"!==r.kind&&o(`Condition in while must be boolean, got '${typeToString(r)}'`,e.cond),p(e.body,n,t);break}case"ForStmt":{const r=new Env(n);if(e.init&&p(e.init,r,t),e.test){const n=a(e.test,r);"boolean"!==n.kind&&"any"!==n.kind&&o(`Condition in for must be boolean, got '${typeToString(n)}'`,e.test)}e.update&&a(e.update,r),p(e.body,r,t);break}case"ForOfStmt":{const r=a(e.right,n);let u=anyType();!r||"array"!==r.kind&&"any"!==r.kind?o(`Right-hand side of for-of must be an array, got '${typeToString(r)}'`,e.right):"array"===r.kind&&(u=r.element);const s=new Env(n);let l=u;if(e.left.typeAnn){const t=i(e.left.typeAnn,n);l=t,c(u,t)||o(`for-of variable type '${typeToString(t)}' is not assignable from element type '${typeToString(u)}'`,e)}s.defineValue(e.left.name,l),p(e.body,s,t);break}case"ForInStmt":{a(e.right,n);const r=primitiveType("string")||anyType(),u=new Env(n);let s=r;if(e.left.typeAnn){const t=i(e.left.typeAnn,n);s=t,c(r,t)||o(`for-in variable type '${typeToString(t)}' is not assignable from key type '${typeToString(r)}'`,e)}u.defineValue(e.left.name,s),p(e.body,u,t);break}case"ClassDecl":{const t=new Map,r=new Map,o={kind:"object",properties:r};let p=functionType([],o);for(const u of e.methods){const e=u.params.map(e=>e.type?i(e.type,n):anyType());if(u.isConstructor)p=functionType(e,o);else{const n=functionType(e,anyType());t.set(u.name,n),r.set(u.name,n)}}const a={kind:"class",name:e.name,ctor:p,methods:t,instance:o};n.defineValue(e.name,a);for(const r of e.methods){const e=r.isConstructor?p:t.get(r.name)||functionType([],anyType()),o=new Env(n);r.params.forEach((n,t)=>o.defineValue(n.name,e.params[t]||anyType())),u(r.body,o,e)}break}case"TryStmt":if(u(e.tryBlock,n,t),e.catchClause){const r=new Env(n);r.defineValue(e.catchClause.name,anyType()),u(e.catchClause.block,r,t)}e.finallyBlock&&u(e.finallyBlock,n,t);break;case"SwitchStmt":a(e.discriminant,n);for(const r of e.cases){r.test&&a(r.test,n);for(const e of r.consequent)p(e,n,t)}break;case"BreakStmt":break;default:o("Unknown statement kind: "+e.kind,e)}}function u(e,n,t){const r=new Env(n);for(const n of e.statements)p(n,r,t)}function a(e,n){switch(e.kind){case"NumberLiteral":return primitiveType("number");case"BigIntLiteral":return primitiveType("bigint");case"StringLiteral":return primitiveType("string");case"BoolLiteral":return primitiveType("boolean");case"Identifier":{const t=n.lookupValue(e.name);return t||anyType()}case"AwaitExpr":return a(e.argument,n);case"BinaryExpr":{if("="===e.op){if("Identifier"!==e.left.kind&&"MemberExpr"!==e.left.kind&&"IndexExpr"!==e.left.kind)return o("Invalid assignment target",e.left),a(e.right,n),anyType();const t=a(e.right,n);let r=null;if("Identifier"===e.left.kind)r=n.lookupValue(e.left.name),r||(r=anyType());else if("MemberExpr"===e.left.kind){const t=a(e.left.object,n);!t||"object"!==t.kind&&"array"!==t.kind&&"any"!==t.kind?(o(`Property access '${e.left.property}' on non-object type '${typeToString(t)}'`,e.left),r=anyType()):"object"===t.kind?(r=t.properties.get(e.left.property),r||(o(`Property '${e.left.property}' does not exist on type '${typeToString(t)}'`,e.left),r=anyType())):r="array"===t.kind&&"length"===e.left.property?primitiveType("number"):anyType()}else{const t=a(e.left.object,n);if(!t||"array"!==t.kind&&"any"!==t.kind)o(`Index access on non-array type '${typeToString(t)}'`,e.left),r=anyType();else if("array"===t.kind){const i=a(e.left.index,n);"number"!==i.kind&&"any"!==i.kind&&o(`Array index must be a number, got '${typeToString(i)}'`,e.left.index),r=t.element}else r=anyType()}return c(t,r)||o(`Cannot assign type '${typeToString(t)}' to '${typeToString(r)}'`,e),r}const t=a(e.left,n),r=a(e.right,n);return"any"===t.kind||"any"===r.kind?["==","!=","<",">","<=",">="].includes(e.op)||["&&","||"].includes(e.op)?primitiveType("boolean"):(["+","-","*","/"].includes(e.op),anyType()):"+"===e.op?"number"===t.kind&&"number"===r.kind?primitiveType("number"):"string"===t.kind&&"string"===r.kind?primitiveType("string"):(o(`Operator '+' not supported for '${typeToString(t)}' and '${typeToString(r)}'`,e),anyType()):["-","*","/"].includes(e.op)?"number"===t.kind&&"number"===r.kind?primitiveType("number"):(o(`Operator '${e.op}' not supported for '${typeToString(t)}' and '${typeToString(r)}'`,e),anyType()):"=="===e.op||"!="===e.op?t.kind===r.kind&&["number","string","boolean","null","undefined","symbol"].includes(t.kind)?primitiveType("boolean"):(o(`Operator '${e.op}' not supported for '${typeToString(t)}' and '${typeToString(r)}'`,e),anyType()):["<",">","<=",">="].includes(e.op)?"number"===t.kind&&"number"===r.kind?primitiveType("boolean"):(o(`Operator '${e.op}' requires numeric operands, got '${typeToString(t)}' and '${typeToString(r)}'`,e),anyType()):"&&"===e.op||"||"===e.op?"boolean"===t.kind&&"boolean"===r.kind?primitiveType("boolean"):(o(`Logical operator '${e.op}' requires boolean operands, got '${typeToString(t)}' and '${typeToString(r)}'`,e),anyType()):anyType()}case"ConditionalExpr":{const t=a(e.cond,n);"boolean"!==t.kind&&"any"!==t.kind&&o(`Condition in ternary must be boolean, got '${typeToString(t)}'`,e);const r=a(e.thenExpr,n),i=a(e.elseExpr,n);return"any"===r.kind||"any"===i.kind?anyType():JSON.stringify(r)===JSON.stringify(i)?r:c(r,i)?i:c(i,r)?r:(o(`Ternary branches have incompatible types: '${typeToString(r)}' and '${typeToString(i)}'`,e),anyType())}case"CallExpr":{if("MemberExpr"===e.callee.kind&&"map"===e.callee.property){const t=a(e.callee.object,n);if(!t||"array"!==t.kind&&"any"!==t.kind)return o(`Attempting to call 'map' on non-array type '${typeToString(t)}'`,e.callee),anyType();if(1!==e.args.length)return o(`Array.map expects 1 argument but got ${e.args.length}`,e),{kind:"array",element:anyType()};const r=e.args[0];if("ArrowFunction"===r.kind){const e=new Env(n),o="array"===t.kind?t.element:anyType(),i=r.params[0]||null;let p;return i&&e.defineValue(i,o),"Block"===r.body.kind?(u(r.body,e,{kind:"function",params:[o],returnType:anyType()}),p=anyType()):p=a(r.body,e),{kind:"array",element:p}}{const i=a(r,n);if(!i||"function"!==i.kind&&"any"!==i.kind)return o(`map callback is not a function (got '${typeToString(i)}')`,e),{kind:"array",element:anyType()};if("any"===i.kind)return{kind:"array",element:anyType()};const p=i.params[0]||anyType(),u="array"===t.kind?t.element:anyType();return c(u,p)||o(`map callback parameter type mismatch: expected '${typeToString(p)}' but got '${typeToString(u)}'`,e),{kind:"array",element:i.returnType}}}const t=a(e.callee,n);return!t||"function"!==t.kind&&"any"!==t.kind?(o(`Attempting to call non-function of type '${typeToString(t)}'`,e),anyType()):"any"===t.kind?(e.args.forEach(e=>a(e,n)),anyType()):(e.args.length!==t.params.length&&o(`Function expects ${t.params.length} arguments but got ${e.args.length}`,e),e.args.forEach((r,i)=>{const p=a(r,n),u=t.params[i]||anyType();c(p,u)||o(`Argument ${i+1} type mismatch: expected '${typeToString(u)}' but got '${typeToString(p)}'`,e)}),t.returnType)}case"MemberExpr":{const t=a(e.object,n);if(!t)return anyType();if("any"===t.kind)return anyType();if("array"===t.kind)return"length"===e.property?primitiveType("number"):anyType();if("object"===t.kind){const n=t.properties.get(e.property);return n||(o(`Property '${e.property}' does not exist on type '${typeToString(t)}'`,e),anyType())}return anyType()}case"IndexExpr":{const t=a(e.object,n);if(!t)return anyType();if("any"===t.kind)return a(e.index,n),anyType();if("array"!==t.kind)return o(`Index access on non-array type '${typeToString(t)}'`,e),anyType();const r=a(e.index,n);return"number"!==r.kind&&"any"!==r.kind&&o(`Array index must be a number, got '${typeToString(r)}'`,e.index),t.element}case"NewExpr":{const t=a(e.callee,n);if(t&&"class"===t.kind){const r=t.ctor;return e.args.length!==r.params.length&&o(`Constructor expects ${r.params.length} arguments but got ${e.args.length}`,e),e.args.forEach((e,t)=>{const i=a(e,n),p=r.params[t]||anyType();c(i,p)||o(`Constructor argument ${t+1} type mismatch: expected '${typeToString(p)}' but got '${typeToString(i)}'`,e)}),t.instance||r.returnType||anyType()}return t&&"any"!==t.kind?"function"===t.kind?(e.args.forEach((e,t)=>a(e,n)),t.returnType||anyType()):(o("Cannot use 'new' on non-constructor type",e),e.args.forEach(e=>a(e,n)),anyType()):(e.args.forEach(e=>a(e,n)),anyType())}case"ArrowFunction":return functionType(e.params.map(e=>anyType()),anyType());case"ArrayLiteral":{const t=e.elements;if(0===t.length)return{kind:"array",element:anyType()};const r=a(t[0],n);for(let i=1;i<t.length;i++){const p=a(t[i],n);c(p,r)||o(`Array literal elements have incompatible types: '${typeToString(r)}' and '${typeToString(p)}'`,e)}return{kind:"array",element:r}}case"FunctionExpr":{const t=e.params.map(e=>e.type?i(e.type,n):anyType()),r=e.returnType?i(e.returnType,n):anyType(),o=functionType(t,r),p=new Env(n);return e.params.forEach((e,n)=>p.defineValue(e.name,t[n])),u(e.body,p,o),o}case"UpdateExpr":{const t=a(e.argument,n);return"any"===t.kind?anyType():"number"!==t.kind?(o(`Operator '${e.operator}' requires a numeric operand, got '${typeToString(t)}'`,e),anyType()):primitiveType("number")}case"ObjectLiteral":{const t=new Map;for(const r of e.properties){const e=a(r.value,n);t.set(r.name,e)}return{kind:"object",properties:t}}default:return o("Unknown expression kind: "+e.kind,e),anyType()}}function c(e,n){if(!e||!n)return!1;if("any"===e.kind||"any"===n.kind)return!0;if("array"===e.kind&&"array"===n.kind)return c(e.element,n.element);if(e.kind===n.kind){if("function"===e.kind){if(e.params.length!==n.params.length)return!1;for(let t=0;t<e.params.length;t++)if(!c(e.params[t],n.params[t]))return!1;return c(e.returnType,n.returnType)}if("object"===e.kind){for(const[t,r]of n.properties.entries()){const n=e.properties.get(t);if(!n||!c(n,r))return!1}return!0}return!0}return!1}return["number","string","boolean","void","bigint","null","undefined","symbol","any"].forEach(e=>{r.defineType(e,primitiveType(e))}),function(e,n){for(const t of e.body)p(t,n,null)}(e,r),{errors:t}}function emitJS(e){function n(e){switch(e.kind){case"ExportDecl":{const t=e.decl;return"TypeDecl"===t.kind?"":`export ${n(t)}`}case"TypeDecl":return"";case"VarDecl":return`let ${e.name}`+(e.init?` = ${r(e.init)}`:"")+";";case"ConstDecl":return`const ${e.name}`+(e.init?` = ${r(e.init)}`:"")+";";case"FuncDecl":{const n=e.params.map(e=>e.name).join(", "),r=t(e.body);return`${e.isAsync?"async ":""}function ${e.name}(${n}) ${r}`}case"IfStmt":{const t=e.elseBlock?` else ${n(e.elseBlock)}`:"";return`if (${r(e.cond)}) ${n(e.thenBlock)}${t}`}case"WhileStmt":return`while (${r(e.cond)}) ${n(e.body)}`;case"ForStmt":return`for (${e.init?("VarDecl"===e.init.kind||e.init.kind,n(e.init).replace(/;$/,"")):""}; ${e.test?r(e.test):""}; ${e.update?r(e.update):""}) ${n(e.body)}`;case"ForOfStmt":return`for (${`${e.left.declKind} ${e.left.name}`} of ${r(e.right)}) ${n(e.body)}`;case"ForInStmt":return`for (${`${e.left.declKind} ${e.left.name}`} in ${r(e.right)}) ${n(e.body)}`;case"SwitchStmt":return`switch (${r(e.discriminant)}) {\n${e.cases.map(e=>{if(e.test){const t=e.consequent.map(e=>n(e)).join("\n");return`  case ${r(e.test)}:\n${t.replace(/^/gm,"    ")}`}return`  default:\n${e.consequent.map(e=>n(e)).join("\n").replace(/^/gm,"    ")}`}).join("\n")}\n}`;case"BreakStmt":return"break;";case"ClassDecl":{const n=e.methods.map(e=>{const n=e.params.map(e=>e.name).join(", ");return e.isConstructor?`  constructor(${n}) ${t(e.body)}`:`  ${e.name}(${n}) ${t(e.body)}`}).join("\n\n");return`class ${e.name} {\n${n.replace(/^/gm,"  ")}\n}`}case"Block":return t(e);case"TryStmt":return`${`try ${n(e.tryBlock)}`}${e.catchClause?` catch (${e.catchClause.name}) ${n(e.catchClause.block)}`:""}${e.finallyBlock?` finally ${n(e.finallyBlock)}`:""}`;case"ReturnStmt":return null===e.expr?"return;":`return ${r(e.expr)};`;case"ExprStmt":return`${r(e.expr)};`;default:throw new Error("Unknown stmt kind: "+e.kind)}}function t(e){return"{\n"+e.statements.map(e=>n(e)).filter(Boolean).map(e=>"  "+e).join("\n")+"\n}"}function r(e){switch(e.kind){case"NumberLiteral":case"BigIntLiteral":return String(e.value);case"StringLiteral":return`"${e.value}"`;case"BoolLiteral":return e.value?"true":"false";case"Identifier":return e.name;case"BinaryExpr":return`${r(e.left)} ${e.op} ${r(e.right)}`;case"CallExpr":return`${r(e.callee)}(${e.args.map(r).join(", ")})`;case"MemberExpr":return`${r(e.object)}.${e.property}`;case"IndexExpr":return`${r(e.object)}[${r(e.index)}]`;case"FunctionExpr":{const n=e.params.map(e=>e.name).join(", "),r=e.name?` ${e.name}`:"";return`${e.isAsync?"async ":""}function${r}(${n}) ${t(e.body)}`}case"ConditionalExpr":return`${r(e.cond)} ? ${r(e.thenExpr)} : ${r(e.elseExpr)}`;case"ArrowFunction":{const n=1===e.params.length?e.params[0]:`(${e.params.join(", ")})`,o=e.isAsync?"async ":"";return"Block"===e.body.kind?`${o}${n} => ${t(e.body)}`:`${o}${n} => ${r(e.body)}`}case"AwaitExpr":return`await ${r(e.argument)}`;case"ArrayLiteral":return"["+e.elements.map(r).join(", ")+"]";case"UpdateExpr":return e.prefix?`${e.operator}${r(e.argument)}`:`${r(e.argument)}${e.operator}`;case"ObjectLiteral":return`{ ${e.properties.map(e=>`${e.name}: ${r(e.value)}`).join(", ")} }`;case"NewExpr":return`new ${r(e.callee)}(${e.args.map(r).join(", ")})`;default:throw new Error("Unknown expr kind: "+e.kind)}}return e.body.map(n).filter(Boolean).join("\n")}export function transpile(e){const n=[];let t=e.replace(/^\s*import\b[^\n]*?;(?=\s*(?:\r?\n|$))/gim,e=>(n.push(e.trim()),""));const r=parse(tokenizeTS(t)),{errors:o}=typeCheck(r,e);if(o.length>0){console.log("Type errors:");const n=e.split(/\r?\n/);for(const t of o){const{msg:r,pos:o}=t;let i=1,p=1;for(let n=0;n<e.length&&n!==o;n++)"\n"===e[n]?(i++,p=1):p++;const u=n[i-1]||"",a=`   ${i} | `;console.log(`\nâ€¢ ${r}`),console.log(a+u),console.log(" ".repeat(a.length)+" ".repeat(p-1)+"^")}throw new Error("Type checking failed")}console.log("No type errors.");const i=emitJS(r);return n.length>0?n.join("\n")+"\n\n"+i:i}