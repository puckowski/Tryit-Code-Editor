"use strict";function tokenize(e){const n=[];let t=0;const r=e=>/[a-zA-Z_]/.test(e),i=e=>/[0-9]/.test(e),o=e=>r(e)||i(e);for(;t<e.length;){let u=e[t];if(" "===u||"\t"===u||"\n"===u||"\r"===u){t++;continue}if("/"===u&&"/"===e[t+1]){for(;t<e.length&&"\n"!==e[t];)t++;continue}if('"'===u||"'"===u){const r=u;let i=t++,o="";for(;t<e.length&&e[t]!==r;)"\\"===e[t]&&t+1<e.length?(o+=e[t],o+=e[t+1],t+=2):o+=e[t++];if(e[t]!==r)throw new Error("Unterminated string literal at "+i);t++,n.push({type:"string",value:o,pos:i});continue}if(i(u)){let r=t,o="";for(;t<e.length&&(i(e[t])||"."===e[t]);)o+=e[t++];n.push({type:"number",value:o,pos:r});continue}if(r(u)){let r=t,i="";for(;t<e.length&&o(e[t]);)i+=e[t++];const u=new Set(["type","function","let","const","return","if","else","while","for"]);n.push({type:u.has(i)?"keyword":"identifier",value:i,pos:r});continue}const a=e.substr(t,2);if(new Set(["==","!=","<=",">=","&&","||","=>","++","--"]).has(a)){n.push({type:"punct",value:a,pos:t}),t+=2;continue}if(!["{","}","(",")",";","+","-","*","/","=",",",":",".","<",">","[","]"].includes(u))throw new Error("Unexpected character: '"+u+"' at position "+t);n.push({type:"punct",value:u,pos:t}),t++}return n}const tokenizeTS=tokenize;function Program(e){return{kind:"Program",body:e}}function TypeDecl(e,n){return{kind:"TypeDecl",name:e,type:n}}function VarDecl(e,n,t){return{kind:"VarDecl",name:e,type:n,init:t}}function ConstDecl(e,n,t){return{kind:"ConstDecl",name:e,type:n,init:t}}function FuncDecl(e,n,t,r){return{kind:"FuncDecl",name:e,params:n,returnType:t,body:r}}function Param(e,n){return{kind:"Param",name:e,type:n}}function Block(e){return{kind:"Block",statements:e}}function ReturnStmt(e){return{kind:"ReturnStmt",expr:e}}function ExprStmt(e){return{kind:"ExprStmt",expr:e}}function ForStmt(e,n,t,r){return{kind:"ForStmt",init:e,test:n,update:t,body:r}}function ForOfStmt(e,n,t){return{kind:"ForOfStmt",left:e,right:n,body:t}}function ForInStmt(e,n,t){return{kind:"ForInStmt",left:e,right:n,body:t}}function TypeRef(e){return{kind:"TypeRef",name:e}}function ObjectType(e){return{kind:"ObjectType",properties:e}}function TypeProperty(e,n){return{kind:"TypeProperty",name:e,type:n}}function ArrayType(e){return{kind:"ArrayType",element:e}}function Identifier(e){return{kind:"Identifier",name:e}}function NumberLiteral(e){return{kind:"NumberLiteral",value:e}}function StringLiteral(e){return{kind:"StringLiteral",value:e}}function BoolLiteral(e){return{kind:"BoolLiteral",value:e}}function BinaryExpr(e,n,t){return{kind:"BinaryExpr",op:e,left:n,right:t}}function CallExpr(e,n){return{kind:"CallExpr",callee:e,args:n}}function MemberExpr(e,n){return{kind:"MemberExpr",object:e,property:n}}function ArrayLiteral(e){return{kind:"ArrayLiteral",elements:e}}function IndexExpr(e,n){return{kind:"IndexExpr",object:e,index:n}}function ArrowFunction(e,n){return{kind:"ArrowFunction",params:e,body:n}}function UpdateExpr(e,n,t){return{kind:"UpdateExpr",argument:e,operator:n,prefix:t}}function parse(e){let n=0;function t(t=0){return e[n+t]||{type:"eof",value:"",pos:e.length}}function r(e,r){const i=t();if(e&&i.type!==e)throw new Error(`Expected token type ${e}, got ${i.type} at ${i.pos}`);if(r&&i.value!==r)throw new Error(`Expected '${r}', got '${i.value}' at ${i.pos}`);return n++,i}function i(e,r){const i=t();return!(i.type!==e||r&&i.value!==r)&&(n++,!0)}function o(){const e=t();return"punct"===e.type&&"{"===e.value?function(){r("punct","{");const e=[];for(;"punct"!==t().type||"}"!==t().value;){const n=r("identifier");r("punct",":");const i=o();if(e.push(TypeProperty(n.value,i)),"punct"!==t().type||","!==t().value)break;r("punct",",")}return r("punct","}"),ObjectType(e)}():u()}function u(){const e=t();if("identifier"===e.type){r("identifier");let n=TypeRef(e.value);for(;"punct"===t().type&&"["===t().value;)r("punct","["),r("punct","]"),n=ArrayType(n);return n}throw new Error("Expected type name at "+e.pos)}function a(){const e=t();if("keyword"===e.type&&"type"===e.value)return function(){r("keyword","type");const e=r("identifier");r("punct","=");const n=o();return r("punct",";"),TypeDecl(e.value,n)}();if("keyword"===e.type&&"function"===e.value)return function(){r("keyword","function");const e=r("identifier");r("punct","(");const n=[];if(!i("punct",")")){do{const e=r("identifier");r("punct",":");const t=u();n.push(Param(e.value,t))}while(i("punct",","));r("punct",")")}r("punct",":");const t=u(),o=p();return FuncDecl(e.value,n,t,o)}();if("keyword"===e.type&&"let"===e.value)return function(){r("keyword","let");const e=r("identifier");let n=null;"punct"===t().type&&":"===t().value&&(r("punct",":"),n=u());let i=null;"punct"===t().type&&"="===t().value&&(r("punct","="),i=c());return r("punct",";"),VarDecl(e.value,n,i)}();if("keyword"===e.type&&"const"===e.value)return function(){r("keyword","const");const e=r("identifier");let n=null;"punct"===t().type&&":"===t().value&&(r("punct",":"),n=u());if("punct"===t().type&&"="===t().value){r("punct","=");const t=c();return r("punct",";"),ConstDecl(e.value,n,t)}throw new Error(`Const '${e.value}' must have an initializer at ${e.pos}`)}();if("keyword"===e.type&&"if"===e.value)return function(){r("keyword","if"),r("punct","(");const e=c();r("punct",")");const n=p();let i=null;"keyword"===t().type&&"else"===t().value&&(r("keyword","else"),i=p());return{kind:"IfStmt",cond:e,thenBlock:n,elseBlock:i}}();if("keyword"===e.type&&"while"===e.value)return function(){r("keyword","while"),r("punct","(");const e=c();r("punct",")");const n=p();return{kind:"WhileStmt",cond:e,body:n}}();if("keyword"===e.type&&"for"===e.value)return function(){if(r("keyword","for"),r("punct","("),"keyword"===t().type&&("let"===t().value||"const"===t().value)){const e=t().value;r("keyword");const n=r("identifier");let i=null;if("punct"===t().type&&":"===t().value&&(r("punct",":"),i=u()),"identifier"===t().type&&("of"===t().value||"in"===t().value)){const o=t().value;r("identifier");const u=c();r("punct",")");const a=p(),l={declKind:e,name:n.value,typeAnn:i};return"of"===o?ForOfStmt(l,u,a):ForInStmt(l,u,a)}let o=null;"punct"===t().type&&"="===t().value&&(r("punct","="),o=c());const a="let"===e?VarDecl(n.value,i,o):ConstDecl(n.value,i,o);r("punct",";");const l="punct"===t().type&&";"===t().value?null:c();r("punct",";");const y="punct"===t().type&&")"===t().value?null:c();r("punct",")");return ForStmt(a,l,y,p())}let e=null;if("punct"!==t().type||";"!==t().value){e=ExprStmt(c())}r("punct",";");const n="punct"===t().type&&";"===t().value?null:c();r("punct",";");const i="punct"===t().type&&")"===t().value?null:c();r("punct",")");const o=p();return ForStmt(e,n,i,o)}();if("keyword"===e.type&&"return"===e.value)return function(){if(r("keyword","return"),"punct"===t().type&&";"===t().value)return r("punct",";"),ReturnStmt(null);const e=c();return r("punct",";"),ReturnStmt(e)}();const n=c();return r("punct",";"),ExprStmt(n)}function p(){r("punct","{");const e=[];for(;"punct"!==t().type||"}"!==t().value;)e.push(a());return r("punct","}"),Block(e)}function c(){return l()}function l(){let e=function(){let e=y();for(;;){const r=t();if("punct"!==r.type||"||"!==r.value)break;{n++;const t=y();e=BinaryExpr(r.value,e,t)}}return e}();const r=t();if("punct"===r.type&&"="===r.value){n++;e=BinaryExpr("=",e,l())}return e}function y(){let e=s();for(;;){const r=t();if("punct"!==r.type||"&&"!==r.value)break;{n++;const t=s();e=BinaryExpr(r.value,e,t)}}return e}function s(){let e=f();for(;;){const r=t();if("punct"!==r.type||"=="!==r.value&&"!="!==r.value)break;{n++;const t=f();e=BinaryExpr(r.value,e,t)}}return e}function f(){let e=d();for(;;){const r=t();if("punct"!==r.type||"<"!==r.value&&">"!==r.value&&"<="!==r.value&&">="!==r.value)break;{n++;const t=d();e=BinaryExpr(r.value,e,t)}}return e}function d(){let e=m();for(;;){const r=t();if("punct"!==r.type||"+"!==r.value&&"-"!==r.value)break;{n++;const t=m();e=BinaryExpr(r.value,e,t)}}return e}function m(){let e=k();for(;;){const r=t();if("punct"!==r.type||"*"!==r.value&&"/"!==r.value)break;{n++;const t=k();e=BinaryExpr(r.value,e,t)}}return e}function k(){let o=function(){const o=t();if("number"===o.type)return r("number"),NumberLiteral(Number(o.value));if("string"===o.type)return r("string"),StringLiteral(o.value);if("punct"===o.type&&"["===o.value){r("punct","[");const u=[];if("punct"!==t().type||"]"!==t().value)do{u.push(c())}while(i("punct",","));return r("punct","]"),ArrayLiteral(u)}if("identifier"===o.type&&"punct"===t(1).type&&"=>"===t(1).value){const a=r("identifier");let l;return r("punct","=>"),l="punct"===t().type&&"{"===t().value?p():c(),ArrowFunction([a.value],l)}if("identifier"===o.type)return"true"===o.value||"false"===o.value?(r("identifier"),BoolLiteral("true"===o.value)):(r("identifier"),Identifier(o.value));if("punct"===o.type&&"("===o.value){function y(){let r=n+1;if("punct"===t(1).type&&")"===t(1).value)return"punct"===t(2).type&&"=>"===t(2).value;for(;;){const n=e[r];if(!n)return!1;if("identifier"===n.type){if(r++,e[r]&&"punct"===e[r].type&&","===e[r].value){r++;continue}return!(!e[r]||"punct"!==e[r].type||")"!==e[r].value)&&(e[r+1]&&"punct"===e[r+1].type&&"=>"===e[r+1].value)}return!1}}if(y()){r("punct","(");const f=[];if("punct"!==t().type||")"!==t().value)do{const m=r("identifier");f.push(m.value)}while(i("punct",","));let d;return r("punct",")"),r("punct","=>"),d="punct"===t().type&&"{"===t().value?p():c(),ArrowFunction(f,d)}r("punct","(");const s=c();return r("punct",")"),s}throw new Error("Unexpected token in expression: "+JSON.stringify(o))}();for(;;){const e=t();if("punct"===e.type&&"."===e.value){r("punct",".");o=MemberExpr(o,r("identifier").value)}else if("punct"===e.type&&"["===e.value){r("punct","[");const e=c();r("punct","]"),o=IndexExpr(o,e)}else if("punct"===e.type&&"("===e.value){r("punct","(");const e=[];if("punct"!==t().type||")"!==t().value)do{e.push(c())}while(i("punct",","));r("punct",")"),o=CallExpr(o,e)}else{if("punct"!==e.type||"++"!==e.value&&"--"!==e.value)break;r("punct",e.value),o=UpdateExpr(o,e.value,!1)}}return o}const T=[];for(;"eof"!==t().type;)T.push(a());return Program(T)}function primitiveType(e){return["number","string","boolean","void"].includes(e)?{kind:e}:null}function anyType(){return{kind:"any"}}function functionType(e,n){return{kind:"function",params:e,returnType:n}}function objectTypeFromAst(e,n,t){const r=new Map;for(const i of e.properties){const e=t(i.type,n);r.set(i.name,e)}return{kind:"object",properties:r}}function typeToString(e){if(!e)return"unknown";if("any"===e.kind)return"any";if("function"===e.kind)return`(${e.params.map(typeToString).join(", ")}) => ${typeToString(e.returnType)}`;if("object"===e.kind){const n=[];for(const[t,r]of e.properties.entries())n.push(`${t}: ${typeToString(r)}`);return`{ ${n.join("; ")} }`}return"array"===e.kind?`${typeToString(e.element)}[]`:e.kind}class Env{constructor(e=null){this.parent=e,this.types=new Map,this.values=new Map}defineType(e,n){this.types.set(e,n)}lookupType(e){return this.types.has(e)?this.types.get(e):this.parent?this.parent.lookupType(e):null}defineValue(e,n){this.values.set(e,n)}lookupValue(e){return this.values.has(e)?this.values.get(e):this.parent?this.parent.lookupValue(e):null}}function typeCheck(e){const n=[],t=new Env;function r(e){n.push(e)}function i(e,n){switch(e.kind){case"TypeRef":{const t=primitiveType(e.name);if(t)return t;const i=n.lookupType(e.name);return i||(r(`Unknown type '${e.name}'`),primitiveType("void"))}case"ArrayType":return{kind:"array",element:i(e.element,n)};case"ObjectType":return objectTypeFromAst(e,n,i);default:return r("Unknown type expression kind: "+e.kind),primitiveType("void")}}function o(e,n,t){switch(e.kind){case"TypeDecl":{const t=i(e.type,n);n.defineType(e.name,t);break}case"VarDecl":{let t=e.type?i(e.type,n):null,o=null;e.init&&(o=a(e.init,n)),t&&o&&!p(o,t)&&r(`Cannot assign type '${typeToString(o)}' to '${typeToString(t)}' (variable '${e.name}')`),!t&&o&&(t=o),t||(t=anyType()),n.defineValue(e.name,t);break}case"ConstDecl":{let t=e.type?i(e.type,n):null;if(!e.init){r(`Const '${e.name}' must have an initializer`),t=t||anyType(),n.defineValue(e.name,t);break}const o=a(e.init,n);t&&!p(o,t)&&r(`Cannot assign type '${typeToString(o)}' to '${typeToString(t)}' (const '${e.name}')`),t||(t=o||anyType()),n.defineValue(e.name,t);break}case"FuncDecl":{const t=e.params.map(e=>i(e.type,n)),r=i(e.returnType,n),o=functionType(t,r);n.defineValue(e.name,o);const a=new Env(n);e.params.forEach((e,n)=>{a.defineValue(e.name,t[n])}),u(e.body,a,o);break}case"Block":u(e,n,t);break;case"ReturnStmt":{if(!t){r("Return statement not inside function");break}const i=t.returnType;if(null===e.expr)"void"!==i.kind&&r(`Return type mismatch: expected '${typeToString(i)}' but got 'void'`);else{const t=a(e.expr,n);p(t,i)||r(`Return type mismatch: expected '${typeToString(i)}' but got '${typeToString(t)}'`)}break}case"ExprStmt":a(e.expr,n);break;case"IfStmt":{const i=a(e.cond,n);"boolean"!==i.kind&&"any"!==i.kind&&r(`Condition in if must be boolean, got '${typeToString(i)}'`),o(e.thenBlock,n,t),e.elseBlock&&o(e.elseBlock,n,t);break}case"WhileStmt":{const i=a(e.cond,n);"boolean"!==i.kind&&"any"!==i.kind&&r(`Condition in while must be boolean, got '${typeToString(i)}'`),o(e.body,n,t);break}case"ForStmt":{const i=new Env(n);if(e.init&&o(e.init,i,t),e.test){const n=a(e.test,i);"boolean"!==n.kind&&"any"!==n.kind&&r(`Condition in for must be boolean, got '${typeToString(n)}'`)}e.update&&a(e.update,i),o(e.body,i,t);break}case"ForOfStmt":{const u=a(e.right,n);let c=anyType();!u||"array"!==u.kind&&"any"!==u.kind?r(`Right-hand side of for-of must be an array, got '${typeToString(u)}'`):"array"===u.kind&&(c=u.element);const l=new Env(n);let y=c;if(e.left.typeAnn){const t=i(e.left.typeAnn,n);y=t,p(c,t)||r(`for-of variable type '${typeToString(t)}' is not assignable from element type '${typeToString(c)}'`)}l.defineValue(e.left.name,y),o(e.body,l,t);break}case"ForInStmt":{a(e.right,n);const u=primitiveType("string")||anyType(),c=new Env(n);let l=u;if(e.left.typeAnn){const t=i(e.left.typeAnn,n);l=t,p(u,t)||r(`for-in variable type '${typeToString(t)}' is not assignable from key type '${typeToString(u)}'`)}c.defineValue(e.left.name,l),o(e.body,c,t);break}default:r("Unknown statement kind: "+e.kind)}}function u(e,n,t){const r=new Env(n);for(const n of e.statements)o(n,r,t)}function a(e,n){switch(e.kind){case"NumberLiteral":return primitiveType("number");case"StringLiteral":return primitiveType("string");case"BoolLiteral":return primitiveType("boolean");case"Identifier":{const t=n.lookupValue(e.name);return t||anyType()}case"BinaryExpr":{if("="===e.op){if("Identifier"!==e.left.kind&&"MemberExpr"!==e.left.kind&&"IndexExpr"!==e.left.kind)return r("Invalid assignment target"),a(e.right,n),anyType();const t=a(e.right,n);let i=null;if("Identifier"===e.left.kind)i=n.lookupValue(e.left.name),i||(i=anyType());else if("MemberExpr"===e.left.kind){const t=a(e.left.object,n);!t||"object"!==t.kind&&"array"!==t.kind&&"any"!==t.kind?(r(`Property access '${e.left.property}' on non-object type '${typeToString(t)}'`),i=anyType()):"object"===t.kind?(i=t.properties.get(e.left.property),i||(r(`Property '${e.left.property}' does not exist on type '${typeToString(t)}'`),i=anyType())):i="array"===t.kind&&"length"===e.left.property?primitiveType("number"):anyType()}else{const t=a(e.left.object,n);if(!t||"array"!==t.kind&&"any"!==t.kind)r(`Index access on non-array type '${typeToString(t)}'`),i=anyType();else if("array"===t.kind){const o=a(e.left.index,n);"number"!==o.kind&&"any"!==o.kind&&r(`Array index must be a number, got '${typeToString(o)}'`),i=t.element}else i=anyType()}return p(t,i)||r(`Cannot assign type '${typeToString(t)}' to '${typeToString(i)}'`),i}const t=a(e.left,n),i=a(e.right,n);return"any"===t.kind||"any"===i.kind?["==","!=","<",">","<=",">=","&&","||"].includes(e.op)?primitiveType("boolean"):(["+","-","*","/"].includes(e.op),anyType()):"+"===e.op?"number"===t.kind&&"number"===i.kind?primitiveType("number"):"string"===t.kind&&"string"===i.kind?primitiveType("string"):(r(`Operator '+' not supported for '${typeToString(t)}' and '${typeToString(i)}'`),anyType()):["-","*","/"].includes(e.op)?"number"===t.kind&&"number"===i.kind?primitiveType("number"):(r(`Operator '${e.op}' not supported for '${typeToString(t)}' and '${typeToString(i)}'`),anyType()):"=="===e.op||"!="===e.op?t.kind===i.kind&&["number","string","boolean"].includes(t.kind)?primitiveType("boolean"):(r(`Operator '${e.op}' not supported for '${typeToString(t)}' and '${typeToString(i)}'`),anyType()):["<",">","<=",">="].includes(e.op)?"number"===t.kind&&"number"===i.kind?primitiveType("boolean"):(r(`Operator '${e.op}' requires numeric operands, got '${typeToString(t)}' and '${typeToString(i)}'`),anyType()):"&&"===e.op||"||"===e.op?"boolean"===t.kind&&"boolean"===i.kind?primitiveType("boolean"):(r(`Logical operator '${e.op}' requires boolean operands, got '${typeToString(t)}' and '${typeToString(i)}'`),anyType()):anyType()}case"CallExpr":{if("MemberExpr"===e.callee.kind&&"map"===e.callee.property){const t=a(e.callee.object,n);if(!t||"array"!==t.kind&&"any"!==t.kind)return r(`Attempting to call 'map' on non-array type '${typeToString(t)}'`),anyType();if(1!==e.args.length)return r(`Array.map expects 1 argument but got ${e.args.length}`),{kind:"array",element:anyType()};const i=e.args[0];if("ArrowFunction"===i.kind){const e=new Env(n),r="array"===t.kind?t.element:anyType(),o=i.params[0]||null;let p;return o&&e.defineValue(o,r),"Block"===i.body.kind?(u(i.body,e,{kind:"function",params:[r],returnType:anyType()}),p=anyType()):p=a(i.body,e),{kind:"array",element:p}}{const e=a(i,n);if(!e||"function"!==e.kind&&"any"!==e.kind)return r(`map callback is not a function (got '${typeToString(e)}')`),{kind:"array",element:anyType()};if("any"===e.kind)return{kind:"array",element:anyType()};const o=e.params[0]||anyType(),u="array"===t.kind?t.element:anyType();return p(u,o)||r(`map callback parameter type mismatch: expected '${typeToString(o)}' but got '${typeToString(u)}'`),{kind:"array",element:e.returnType}}}const t=a(e.callee,n);return!t||"function"!==t.kind&&"any"!==t.kind?(r(`Attempting to call non-function of type '${typeToString(t)}'`),anyType()):"any"===t.kind?(e.args.forEach(e=>a(e,n)),anyType()):(e.args.length!==t.params.length&&r(`Function expects ${t.params.length} arguments but got ${e.args.length}`),e.args.forEach((e,i)=>{const o=a(e,n),u=t.params[i]||anyType();p(o,u)||r(`Argument ${i+1} type mismatch: expected '${typeToString(u)}' but got '${typeToString(o)}'`)}),t.returnType)}case"MemberExpr":{const t=a(e.object,n);if(!t)return anyType();if("any"===t.kind)return anyType();if("array"===t.kind&&"length"===e.property)return primitiveType("number");if("object"!==t.kind)return r(`Property access '${e.property}' on non-object type '${typeToString(t)}'`),anyType();const i=t.properties.get(e.property);return i||(r(`Property '${e.property}' does not exist on type '${typeToString(t)}'`),anyType())}case"IndexExpr":{const t=a(e.object,n);if(!t)return anyType();if("any"===t.kind)return a(e.index,n),anyType();if("array"!==t.kind)return r(`Index access on non-array type '${typeToString(t)}'`),anyType();const i=a(e.index,n);return"number"!==i.kind&&"any"!==i.kind&&r(`Array index must be a number, got '${typeToString(i)}'`),t.element}case"ArrowFunction":return functionType(e.params.map(e=>anyType()),anyType());case"ArrayLiteral":{const t=e.elements;if(0===t.length)return{kind:"array",element:anyType()};const i=a(t[0],n);for(let e=1;e<t.length;e++){const o=a(t[e],n);p(o,i)||r(`Array literal elements have incompatible types: '${typeToString(i)}' and '${typeToString(o)}'`)}return{kind:"array",element:i}}case"UpdateExpr":{const t=a(e.argument,n);return"any"===t.kind?anyType():"number"!==t.kind?(r(`Operator '${e.operator}' requires a numeric operand, got '${typeToString(t)}'`),anyType()):primitiveType("number")}default:return r("Unknown expression kind: "+e.kind),anyType()}}function p(e,n){if(!e||!n)return!1;if("any"===e.kind||"any"===n.kind)return!0;if("array"===e.kind&&"array"===n.kind)return p(e.element,n.element);if(e.kind===n.kind){if("function"===e.kind){if(e.params.length!==n.params.length)return!1;for(let t=0;t<e.params.length;t++)if(!p(e.params[t],n.params[t]))return!1;return p(e.returnType,n.returnType)}if("object"===e.kind){for(const[t,r]of n.properties.entries()){const n=e.properties.get(t);if(!n||!p(n,r))return!1}return!0}return!0}return!1}return["number","string","boolean","void"].forEach(e=>{t.defineType(e,primitiveType(e))}),function(e,n){for(const t of e.body)o(t,n,null)}(e,t),{errors:n}}function emitJS(e){function n(e){switch(e.kind){case"TypeDecl":return"";case"VarDecl":return`let ${e.name}`+(e.init?` = ${r(e.init)}`:"")+";";case"ConstDecl":return`const ${e.name}`+(e.init?` = ${r(e.init)}`:"")+";";case"FuncDecl":{const n=e.params.map(e=>e.name).join(", "),r=t(e.body);return`function ${e.name}(${n}) ${r}`}case"IfStmt":{const t=e.elseBlock?` else ${n(e.elseBlock)}`:"";return`if (${r(e.cond)}) ${n(e.thenBlock)}${t}`}case"WhileStmt":return`while (${r(e.cond)}) ${n(e.body)}`;case"ForStmt":return`for (${e.init?("VarDecl"===e.init.kind||e.init.kind,n(e.init).replace(/;$/,"")):""}; ${e.test?r(e.test):""}; ${e.update?r(e.update):""}) ${n(e.body)}`;case"ForOfStmt":return`for (${`${e.left.declKind} ${e.left.name}`} of ${r(e.right)}) ${n(e.body)}`;case"ForInStmt":return`for (${`${e.left.declKind} ${e.left.name}`} in ${r(e.right)}) ${n(e.body)}`;case"Block":return t(e);case"ReturnStmt":return null===e.expr?"return;":`return ${r(e.expr)};`;case"ExprStmt":return`${r(e.expr)};`;default:throw new Error("Unknown stmt kind: "+e.kind)}}function t(e){return"{\n"+e.statements.map(e=>n(e)).filter(Boolean).map(e=>"  "+e).join("\n")+"\n}"}function r(e){switch(e.kind){case"NumberLiteral":return String(e.value);case"StringLiteral":return`"${e.value}"`;case"BoolLiteral":return e.value?"true":"false";case"Identifier":return e.name;case"BinaryExpr":return`${r(e.left)} ${e.op} ${r(e.right)}`;case"CallExpr":return`${r(e.callee)}(${e.args.map(r).join(", ")})`;case"MemberExpr":return`${r(e.object)}.${e.property}`;case"IndexExpr":return`${r(e.object)}[${r(e.index)}]`;case"ArrowFunction":{const n=1===e.params.length?e.params[0]:`(${e.params.join(", ")})`;return"Block"===e.body.kind?`${n} => ${t(e.body)}`:`${n} => ${r(e.body)}`}case"ArrayLiteral":return"["+e.elements.map(r).join(", ")+"]";case"UpdateExpr":return e.prefix?`${e.operator}${r(e.argument)}`:`${r(e.argument)}${e.operator}`;default:throw new Error("Unknown expr kind: "+e.kind)}}return e.body.map(n).filter(Boolean).join("\n")}export function transpile(e){const n=parse(tokenizeTS(e)),{errors:t}=typeCheck(n);if(t.length>0){console.log("\n=== TYPE ERRORS ===");for(const e of t)console.log("â€¢ "+e);throw new Error("Type checking failed")}console.log("\nNo type errors.");return emitJS(n)}