"use strict";function tokenize(e){const n=[];let t=0;const r=e=>/[a-zA-Z_]/.test(e),o=e=>/[0-9]/.test(e),i=e=>r(e)||o(e);for(;t<e.length;){let p=e[t];if(" "===p||"\t"===p||"\n"===p||"\r"===p){t++;continue}if("/"===p&&"/"===e[t+1]){for(;t<e.length&&"\n"!==e[t];)t++;continue}if('"'===p||"'"===p){const r=p;let o=t++,i="";for(;t<e.length&&e[t]!==r;)"\\"===e[t]&&t+1<e.length?(i+=e[t],i+=e[t+1],t+=2):i+=e[t++];if(e[t]!==r)throw new Error("Unterminated string literal at "+o);t++,n.push({type:"string",value:i,pos:o});continue}if(o(p)){let r=t,i="";for(;t<e.length&&(o(e[t])||"."===e[t]);)i+=e[t++];n.push({type:"number",value:i,pos:r});continue}if(r(p)){let r=t,o="";for(;t<e.length&&i(e[t]);)o+=e[t++];const p=new Set(["type","function","let","const","return","if","else","while","for"]);n.push({type:p.has(o)?"keyword":"identifier",value:o,pos:r});continue}const u=e.substr(t,2);if(new Set(["==","!=","<=",">=","&&","||","=>","++","--"]).has(u)){n.push({type:"punct",value:u,pos:t}),t+=2;continue}if(!["{","}","(",")",";","+","-","*","/","=",",",":",".","<",">","[","]"].includes(p))throw new Error("Unexpected character: '"+p+"' at position "+t);n.push({type:"punct",value:p,pos:t}),t++}return n}const tokenizeTS=tokenize;function Program(e){return{kind:"Program",body:e}}function TypeDecl(e,n,t){return{kind:"TypeDecl",name:e,type:n,pos:t}}function VarDecl(e,n,t,r){return{kind:"VarDecl",name:e,type:n,init:t,pos:r}}function ConstDecl(e,n,t,r){return{kind:"ConstDecl",name:e,type:n,init:t,pos:r}}function FuncDecl(e,n,t,r,o){return{kind:"FuncDecl",name:e,params:n,returnType:t,body:r,pos:o}}function Param(e,n,t){return{kind:"Param",name:e,type:n,pos:t}}function Block(e,n){return{kind:"Block",statements:e,pos:n}}function ReturnStmt(e,n){return{kind:"ReturnStmt",expr:e,pos:n}}function ExprStmt(e,n){return{kind:"ExprStmt",expr:e,pos:n}}function ForStmt(e,n,t,r,o){return{kind:"ForStmt",init:e,test:n,update:t,body:r,pos:o}}function ForOfStmt(e,n,t,r){return{kind:"ForOfStmt",left:e,right:n,body:t,pos:r}}function ForInStmt(e,n,t,r){return{kind:"ForInStmt",left:e,right:n,body:t,pos:r}}function TypeRef(e,n){return{kind:"TypeRef",name:e,pos:n}}function ObjectType(e,n){return{kind:"ObjectType",properties:e,pos:n}}function TypeProperty(e,n,t){return{kind:"TypeProperty",name:e,type:n,pos:t}}function ArrayType(e,n){return{kind:"ArrayType",element:e,pos:n}}function Identifier(e,n){return{kind:"Identifier",name:e,pos:n}}function NumberLiteral(e,n){return{kind:"NumberLiteral",value:e,pos:n}}function StringLiteral(e,n){return{kind:"StringLiteral",value:e,pos:n}}function BoolLiteral(e,n){return{kind:"BoolLiteral",value:e,pos:n}}function BinaryExpr(e,n,t,r){return{kind:"BinaryExpr",op:e,left:n,right:t,pos:r}}function CallExpr(e,n,t){return{kind:"CallExpr",callee:e,args:n,pos:t}}function MemberExpr(e,n,t){return{kind:"MemberExpr",object:e,property:n,pos:t}}function ArrayLiteral(e,n){return{kind:"ArrayLiteral",elements:e,pos:n}}function IndexExpr(e,n,t){return{kind:"IndexExpr",object:e,index:n,pos:t}}function ArrowFunction(e,n,t){return{kind:"ArrowFunction",params:e,body:n,pos:t}}function UpdateExpr(e,n,t,r){return{kind:"UpdateExpr",argument:e,operator:n,prefix:t,pos:r}}function parse(e){let n=0;function t(t=0){return e[n+t]||{type:"eof",value:"",pos:e.length}}function r(e,r){const o=t();if(e&&o.type!==e)throw new Error(`Expected token type ${e}, got ${o.type} at ${o.pos}`);if(r&&o.value!==r)throw new Error(`Expected '${r}', got '${o.value}' at ${o.pos}`);return n++,o}function o(e,r){const o=t();return!(o.type!==e||r&&o.value!==r)&&(n++,!0)}function i(){const e=t();return"punct"===e.type&&"{"===e.value?function(){const e=r("punct","{"),n=[];for(;"punct"!==t().type||"}"!==t().value;){const e=r("identifier");r("punct",":");const o=i();if(n.push(TypeProperty(e.value,o,e.pos)),"punct"!==t().type||","!==t().value)break;r("punct",",")}return r("punct","}"),ObjectType(n,e.pos)}():p()}function p(){const e=t();if("identifier"===e.type){r("identifier");let n=TypeRef(e.value,e.pos);for(;"punct"===t().type&&"["===t().value;){const e=r("punct","[");r("punct","]"),n=ArrayType(n,e.pos)}return n}throw new Error("Expected type name at "+e.pos)}function u(){const e=t();if("keyword"===e.type&&"type"===e.value)return function(){r("keyword","type");const e=r("identifier");r("punct","=");const n=i();return r("punct",";"),TypeDecl(e.value,n,e.pos)}();if("keyword"===e.type&&"function"===e.value)return function(){r("keyword","function");const e=r("identifier");r("punct","(");const n=[];if(!o("punct",")")){do{const e=r("identifier");r("punct",":");const t=p();n.push(Param(e.value,t,e.pos))}while(o("punct",","));r("punct",")")}r("punct",":");const t=p(),i=a();return FuncDecl(e.value,n,t,i,e.pos)}();if("keyword"===e.type&&"let"===e.value)return function(){r("keyword","let");const e=r("identifier");let n=null;"punct"===t().type&&":"===t().value&&(r("punct",":"),n=p());let o=null;"punct"===t().type&&"="===t().value&&(r("punct","="),o=c());return r("punct",";"),VarDecl(e.value,n,o,e.pos)}();if("keyword"===e.type&&"const"===e.value)return function(){r("keyword","const");const e=r("identifier");let n=null;"punct"===t().type&&":"===t().value&&(r("punct",":"),n=p());if("punct"===t().type&&"="===t().value){r("punct","=");const t=c();return r("punct",";"),ConstDecl(e.value,n,t,e.pos)}throw new Error(`Const '${e.value}' must have an initializer at ${e.pos}`)}();if("keyword"===e.type&&"if"===e.value)return function(){const e=r("keyword","if");r("punct","(");const n=c();r("punct",")");const o=a();let i=null;"keyword"===t().type&&"else"===t().value&&(r("keyword","else"),i=a());return{kind:"IfStmt",cond:n,thenBlock:o,elseBlock:i,pos:e.pos}}();if("keyword"===e.type&&"while"===e.value)return function(){const e=r("keyword","while");r("punct","(");const n=c();r("punct",")");const t=a();return{kind:"WhileStmt",cond:n,body:t,pos:e.pos}}();if("keyword"===e.type&&"for"===e.value)return function(){const e=r("keyword","for");if(r("punct","("),"keyword"===t().type&&("let"===t().value||"const"===t().value)){const n=t().value;r("keyword");const o=r("identifier");let i=null;if("punct"===t().type&&":"===t().value&&(r("punct",":"),i=p()),"identifier"===t().type&&("of"===t().value||"in"===t().value)){const p=t().value;r("identifier");const u=c();r("punct",")");const s=a(),l={declKind:n,name:o.value,typeAnn:i,pos:o.pos};return"of"===p?ForOfStmt(l,u,s,e.pos):ForInStmt(l,u,s,e.pos)}let u=null;"punct"===t().type&&"="===t().value&&(r("punct","="),u=c());const s="let"===n?VarDecl(o.value,i,u,o.pos):ConstDecl(o.value,i,u,o.pos);r("punct",";");const l="punct"===t().type&&";"===t().value?null:c();r("punct",";");const y="punct"===t().type&&")"===t().value?null:c();r("punct",")");return ForStmt(s,l,y,a(),e.pos)}let n=null;if("punct"!==t().type||";"!==t().value){const e=c();n=ExprStmt(e,e.pos)}r("punct",";");const o="punct"===t().type&&";"===t().value?null:c();r("punct",";");const i="punct"===t().type&&")"===t().value?null:c();r("punct",")");const u=a();return ForStmt(n,o,i,u,e.pos)}();if("keyword"===e.type&&"return"===e.value)return function(){const e=r("keyword","return");if("punct"===t().type&&";"===t().value)return r("punct",";"),ReturnStmt(null,e.pos);const n=c();return r("punct",";"),ReturnStmt(n,e.pos)}();return ExprStmt(c(),r("punct",";").pos)}function a(){const e=r("punct","{"),n=[];for(;"punct"!==t().type||"}"!==t().value;)n.push(u());return r("punct","}"),Block(n,e.pos)}function c(){return s()}function s(){let e=function(){let e=l();for(;;){const r=t();if("punct"!==r.type||"||"!==r.value)break;{n++;const t=l();e=BinaryExpr(r.value,e,t,r.pos)}}return e}();const r=t();if("punct"===r.type&&"="===r.value){n++;e=BinaryExpr("=",e,s(),r.pos)}return e}function l(){let e=y();for(;;){const r=t();if("punct"!==r.type||"&&"!==r.value)break;{n++;const t=y();e=BinaryExpr(r.value,e,t,r.pos)}}return e}function y(){let e=f();for(;;){const r=t();if("punct"!==r.type||"=="!==r.value&&"!="!==r.value)break;{n++;const t=f();e=BinaryExpr(r.value,e,t,r.pos)}}return e}function f(){let e=d();for(;;){const r=t();if("punct"!==r.type||"<"!==r.value&&">"!==r.value&&"<="!==r.value&&">="!==r.value)break;{n++;const t=d();e=BinaryExpr(r.value,e,t,r.pos)}}return e}function d(){let e=m();for(;;){const r=t();if("punct"!==r.type||"+"!==r.value&&"-"!==r.value)break;{n++;const t=m();e=BinaryExpr(r.value,e,t,r.pos)}}return e}function m(){let e=k();for(;;){const r=t();if("punct"!==r.type||"*"!==r.value&&"/"!==r.value)break;{n++;const t=k();e=BinaryExpr(r.value,e,t,r.pos)}}return e}function k(){let i=function(){const i=t();if("number"===i.type)return r("number"),NumberLiteral(Number(i.value),i.pos);if("string"===i.type)return r("string"),StringLiteral(i.value,i.pos);if("punct"===i.type&&"["===i.value){const p=r("punct","["),u=[];if("punct"!==t().type||"]"!==t().value)do{u.push(c())}while(o("punct",","));return r("punct","]"),ArrayLiteral(u,p.pos)}if("identifier"===i.type&&"punct"===t(1).type&&"=>"===t(1).value){const s=r("identifier");let l;return r("punct","=>"),l="punct"===t().type&&"{"===t().value?a():c(),ArrowFunction([s.value],l,s.pos)}if("identifier"===i.type)return"true"===i.value||"false"===i.value?(r("identifier"),BoolLiteral("true"===i.value,i.pos)):(r("identifier"),Identifier(i.value,i.pos));if("punct"===i.type&&"("===i.value){function y(){let r=n+1;if("punct"===t(1).type&&")"===t(1).value)return"punct"===t(2).type&&"=>"===t(2).value;for(;;){const n=e[r];if(!n)return!1;if("identifier"===n.type){if(r++,e[r]&&"punct"===e[r].type&&","===e[r].value){r++;continue}return!(!e[r]||"punct"!==e[r].type||")"!==e[r].value)&&(e[r+1]&&"punct"===e[r+1].type&&"=>"===e[r+1].value)}return!1}}if(y()){const d=r("punct","("),m=[];if("punct"!==t().type||")"!==t().value)do{const g=r("identifier");m.push(g.value)}while(o("punct",","));let k;return r("punct",")"),r("punct","=>"),k="punct"===t().type&&"{"===t().value?a():c(),ArrowFunction(m,k,d.pos)}r("punct","(");const f=c();return r("punct",")"),f}throw new Error("Unexpected token in expression: "+JSON.stringify(i))}();for(;;){const e=t();if("punct"===e.type&&"."===e.value){r("punct",".");const e=r("identifier");i=MemberExpr(i,e.value,e.pos)}else if("punct"===e.type&&"["===e.value){const e=r("punct","["),n=c();r("punct","]"),i=IndexExpr(i,n,e.pos)}else if("punct"===e.type&&"("===e.value){const e=r("punct","("),n=[];if("punct"!==t().type||")"!==t().value)do{n.push(c())}while(o("punct",","));r("punct",")"),i=CallExpr(i,n,e.pos)}else{if("punct"!==e.type||"++"!==e.value&&"--"!==e.value)break;r("punct",e.value),i=UpdateExpr(i,e.value,!1,e.pos)}}return i}const g=[];for(;"eof"!==t().type;)g.push(u());return Program(g)}function primitiveType(e){return["number","string","boolean","void"].includes(e)?{kind:e}:null}function anyType(){return{kind:"any"}}function functionType(e,n){return{kind:"function",params:e,returnType:n}}function objectTypeFromAst(e,n,t){const r=new Map;for(const o of e.properties){const e=t(o.type,n);r.set(o.name,e)}return{kind:"object",properties:r}}function typeToString(e){if(!e)return"unknown";if("any"===e.kind)return"any";if("function"===e.kind)return`(${e.params.map(typeToString).join(", ")}) => ${typeToString(e.returnType)}`;if("object"===e.kind){const n=[];for(const[t,r]of e.properties.entries())n.push(`${t}: ${typeToString(r)}`);return`{ ${n.join("; ")} }`}return"array"===e.kind?`${typeToString(e.element)}[]`:e.kind}class Env{constructor(e=null){this.parent=e,this.types=new Map,this.values=new Map}defineType(e,n){this.types.set(e,n)}lookupType(e){return this.types.has(e)?this.types.get(e):this.parent?this.parent.lookupType(e):null}defineValue(e,n){this.values.set(e,n)}lookupValue(e){return this.values.has(e)?this.values.get(e):this.parent?this.parent.lookupValue(e):null}}function buildPosToLineMap(e){const n=[0];for(let t=0;t<e.length;t++)"\n"===e[t]&&n.push(t+1);return function(e){if("number"!=typeof e||e<0)return null;let t=1;for(let r=0;r<n.length&&n[r]<=e;r++)t=r+1;return t}}function typeCheck(e,n){const t=[],r=new Env;buildPosToLineMap(n);function o(e,n){t.push({msg:e,pos:n&&"number"==typeof n.pos?n.pos:0})}function i(e,n){switch(e.kind){case"TypeRef":{const t=primitiveType(e.name);if(t)return t;const r=n.lookupType(e.name);return r||(o(`Unknown type '${e.name}'`,e),primitiveType("void"))}case"ArrayType":return{kind:"array",element:i(e.element,n)};case"ObjectType":return objectTypeFromAst(e,n,i);default:return o("Unknown type expression kind: "+e.kind,e),primitiveType("void")}}function p(e,n,t){switch(e.kind){case"TypeDecl":{const t=i(e.type,n);n.defineType(e.name,t);break}case"VarDecl":{let t=e.type?i(e.type,n):null,r=null;e.init&&(r=a(e.init,n)),t&&r&&!c(r,t)&&o(`Cannot assign type '${typeToString(r)}' to '${typeToString(t)}' (variable '${e.name}')`,e),!t&&r&&(t=r),t||(t=anyType()),n.defineValue(e.name,t);break}case"ConstDecl":{let t=e.type?i(e.type,n):null;if(!e.init){o(`Const '${e.name}' must have an initializer`,e),t=t||anyType(),n.defineValue(e.name,t);break}const r=a(e.init,n);t&&!c(r,t)&&o(`Cannot assign type '${typeToString(r)}' to '${typeToString(t)}' (const '${e.name}')`,e),t||(t=r||anyType()),n.defineValue(e.name,t);break}case"FuncDecl":{const t=e.params.map(e=>i(e.type,n)),r=i(e.returnType,n),o=functionType(t,r);n.defineValue(e.name,o);const p=new Env(n);e.params.forEach((e,n)=>{p.defineValue(e.name,t[n])}),u(e.body,p,o);break}case"Block":u(e,n,t);break;case"ReturnStmt":{if(!t){o("Return statement not inside function",e);break}const r=t.returnType;if(null===e.expr)"void"!==r.kind&&o(`Return type mismatch: expected '${typeToString(r)}' but got 'void'`,e);else{const t=a(e.expr,n);c(t,r)||o(`Return type mismatch: expected '${typeToString(r)}' but got '${typeToString(t)}'`,e)}break}case"ExprStmt":a(e.expr,n);break;case"IfStmt":{const r=a(e.cond,n);"boolean"!==r.kind&&"any"!==r.kind&&o(`Condition in if must be boolean, got '${typeToString(r)}'`,e.cond),p(e.thenBlock,n,t),e.elseBlock&&p(e.elseBlock,n,t);break}case"WhileStmt":{const r=a(e.cond,n);"boolean"!==r.kind&&"any"!==r.kind&&o(`Condition in while must be boolean, got '${typeToString(r)}'`,e.cond),p(e.body,n,t);break}case"ForStmt":{const r=new Env(n);if(e.init&&p(e.init,r,t),e.test){const n=a(e.test,r);"boolean"!==n.kind&&"any"!==n.kind&&o(`Condition in for must be boolean, got '${typeToString(n)}'`,e.test)}e.update&&a(e.update,r),p(e.body,r,t);break}case"ForOfStmt":{const r=a(e.right,n);let u=anyType();!r||"array"!==r.kind&&"any"!==r.kind?o(`Right-hand side of for-of must be an array, got '${typeToString(r)}'`,e.right):"array"===r.kind&&(u=r.element);const s=new Env(n);let l=u;if(e.left.typeAnn){const t=i(e.left.typeAnn,n);l=t,c(u,t)||o(`for-of variable type '${typeToString(t)}' is not assignable from element type '${typeToString(u)}'`,e)}s.defineValue(e.left.name,l),p(e.body,s,t);break}case"ForInStmt":{a(e.right,n);const r=primitiveType("string")||anyType(),u=new Env(n);let s=r;if(e.left.typeAnn){const t=i(e.left.typeAnn,n);s=t,c(r,t)||o(`for-in variable type '${typeToString(t)}' is not assignable from key type '${typeToString(r)}'`,e)}u.defineValue(e.left.name,s),p(e.body,u,t);break}default:o("Unknown statement kind: "+e.kind,e)}}function u(e,n,t){const r=new Env(n);for(const n of e.statements)p(n,r,t)}function a(e,n){switch(e.kind){case"NumberLiteral":return primitiveType("number");case"StringLiteral":return primitiveType("string");case"BoolLiteral":return primitiveType("boolean");case"Identifier":{const t=n.lookupValue(e.name);return t||anyType()}case"BinaryExpr":{if("="===e.op){if("Identifier"!==e.left.kind&&"MemberExpr"!==e.left.kind&&"IndexExpr"!==e.left.kind)return o("Invalid assignment target",e.left),a(e.right,n),anyType();const t=a(e.right,n);let r=null;if("Identifier"===e.left.kind)r=n.lookupValue(e.left.name),r||(r=anyType());else if("MemberExpr"===e.left.kind){const t=a(e.left.object,n);!t||"object"!==t.kind&&"array"!==t.kind&&"any"!==t.kind?(o(`Property access '${e.left.property}' on non-object type '${typeToString(t)}'`,e.left),r=anyType()):"object"===t.kind?(r=t.properties.get(e.left.property),r||(o(`Property '${e.left.property}' does not exist on type '${typeToString(t)}'`,e.left),r=anyType())):r="array"===t.kind&&"length"===e.left.property?primitiveType("number"):anyType()}else{const t=a(e.left.object,n);if(!t||"array"!==t.kind&&"any"!==t.kind)o(`Index access on non-array type '${typeToString(t)}'`,e.left),r=anyType();else if("array"===t.kind){const i=a(e.left.index,n);"number"!==i.kind&&"any"!==i.kind&&o(`Array index must be a number, got '${typeToString(i)}'`,e.left.index),r=t.element}else r=anyType()}return c(t,r)||o(`Cannot assign type '${typeToString(t)}' to '${typeToString(r)}'`,e),r}const t=a(e.left,n),r=a(e.right,n);return"any"===t.kind||"any"===r.kind?["==","!=","<",">","<=",">=","&&","||"].includes(e.op)?primitiveType("boolean"):(["+","-","*","/"].includes(e.op),anyType()):"+"===e.op?"number"===t.kind&&"number"===r.kind?primitiveType("number"):"string"===t.kind&&"string"===r.kind?primitiveType("string"):(o(`Operator '+' not supported for '${typeToString(t)}' and '${typeToString(r)}'`,e),anyType()):["-","*","/"].includes(e.op)?"number"===t.kind&&"number"===r.kind?primitiveType("number"):(o(`Operator '${e.op}' not supported for '${typeToString(t)}' and '${typeToString(r)}'`,e),anyType()):"=="===e.op||"!="===e.op?t.kind===r.kind&&["number","string","boolean"].includes(t.kind)?primitiveType("boolean"):(o(`Operator '${e.op}' not supported for '${typeToString(t)}' and '${typeToString(r)}'`,e),anyType()):["<",">","<=",">="].includes(e.op)?"number"===t.kind&&"number"===r.kind?primitiveType("boolean"):(o(`Operator '${e.op}' requires numeric operands, got '${typeToString(t)}' and '${typeToString(r)}'`,e),anyType()):"&&"===e.op||"||"===e.op?"boolean"===t.kind&&"boolean"===r.kind?primitiveType("boolean"):(o(`Logical operator '${e.op}' requires boolean operands, got '${typeToString(t)}' and '${typeToString(r)}'`,e),anyType()):anyType()}case"CallExpr":{if("MemberExpr"===e.callee.kind&&"map"===e.callee.property){const t=a(e.callee.object,n);if(!t||"array"!==t.kind&&"any"!==t.kind)return o(`Attempting to call 'map' on non-array type '${typeToString(t)}'`,e.callee),anyType();if(1!==e.args.length)return o(`Array.map expects 1 argument but got ${e.args.length}`,e),{kind:"array",element:anyType()};const r=e.args[0];if("ArrowFunction"===r.kind){const e=new Env(n),o="array"===t.kind?t.element:anyType(),i=r.params[0]||null;let p;return i&&e.defineValue(i,o),"Block"===r.body.kind?(u(r.body,e,{kind:"function",params:[o],returnType:anyType()}),p=anyType()):p=a(r.body,e),{kind:"array",element:p}}{const i=a(r,n);if(!i||"function"!==i.kind&&"any"!==i.kind)return o(`map callback is not a function (got '${typeToString(i)}')`,e),{kind:"array",element:anyType()};if("any"===i.kind)return{kind:"array",element:anyType()};const p=i.params[0]||anyType(),u="array"===t.kind?t.element:anyType();return c(u,p)||o(`map callback parameter type mismatch: expected '${typeToString(p)}' but got '${typeToString(u)}'`,e),{kind:"array",element:i.returnType}}}const t=a(e.callee,n);return!t||"function"!==t.kind&&"any"!==t.kind?(o(`Attempting to call non-function of type '${typeToString(t)}'`,e),anyType()):"any"===t.kind?(e.args.forEach(e=>a(e,n)),anyType()):(e.args.length!==t.params.length&&o(`Function expects ${t.params.length} arguments but got ${e.args.length}`,e),e.args.forEach((r,i)=>{const p=a(r,n),u=t.params[i]||anyType();c(p,u)||o(`Argument ${i+1} type mismatch: expected '${typeToString(u)}' but got '${typeToString(p)}'`,e)}),t.returnType)}case"MemberExpr":{const t=a(e.object,n);if(!t)return anyType();if("any"===t.kind)return anyType();if("array"===t.kind&&"length"===e.property)return primitiveType("number");if("object"!==t.kind)return o(`Property access '${e.property}' on non-object type '${typeToString(t)}'`,e),anyType();const r=t.properties.get(e.property);return r||(o(`Property '${e.property}' does not exist on type '${typeToString(t)}'`,e),anyType())}case"IndexExpr":{const t=a(e.object,n);if(!t)return anyType();if("any"===t.kind)return a(e.index,n),anyType();if("array"!==t.kind)return o(`Index access on non-array type '${typeToString(t)}'`,e),anyType();const r=a(e.index,n);return"number"!==r.kind&&"any"!==r.kind&&o(`Array index must be a number, got '${typeToString(r)}'`,e.index),t.element}case"ArrowFunction":return functionType(e.params.map(e=>anyType()),anyType());case"ArrayLiteral":{const t=e.elements;if(0===t.length)return{kind:"array",element:anyType()};const r=a(t[0],n);for(let i=1;i<t.length;i++){const p=a(t[i],n);c(p,r)||o(`Array literal elements have incompatible types: '${typeToString(r)}' and '${typeToString(p)}'`,e)}return{kind:"array",element:r}}case"UpdateExpr":{const t=a(e.argument,n);return"any"===t.kind?anyType():"number"!==t.kind?(o(`Operator '${e.operator}' requires a numeric operand, got '${typeToString(t)}'`,e),anyType()):primitiveType("number")}default:return o("Unknown expression kind: "+e.kind,e),anyType()}}function c(e,n){if(!e||!n)return!1;if("any"===e.kind||"any"===n.kind)return!0;if("array"===e.kind&&"array"===n.kind)return c(e.element,n.element);if(e.kind===n.kind){if("function"===e.kind){if(e.params.length!==n.params.length)return!1;for(let t=0;t<e.params.length;t++)if(!c(e.params[t],n.params[t]))return!1;return c(e.returnType,n.returnType)}if("object"===e.kind){for(const[t,r]of n.properties.entries()){const n=e.properties.get(t);if(!n||!c(n,r))return!1}return!0}return!0}return!1}return["number","string","boolean","void"].forEach(e=>{r.defineType(e,primitiveType(e))}),function(e,n){for(const t of e.body)p(t,n,null)}(e,r),{errors:t}}function emitJS(e){function n(e){switch(e.kind){case"TypeDecl":return"";case"VarDecl":return`let ${e.name}`+(e.init?` = ${r(e.init)}`:"")+";";case"ConstDecl":return`const ${e.name}`+(e.init?` = ${r(e.init)}`:"")+";";case"FuncDecl":{const n=e.params.map(e=>e.name).join(", "),r=t(e.body);return`function ${e.name}(${n}) ${r}`}case"IfStmt":{const t=e.elseBlock?` else ${n(e.elseBlock)}`:"";return`if (${r(e.cond)}) ${n(e.thenBlock)}${t}`}case"WhileStmt":return`while (${r(e.cond)}) ${n(e.body)}`;case"ForStmt":return`for (${e.init?("VarDecl"===e.init.kind||e.init.kind,n(e.init).replace(/;$/,"")):""}; ${e.test?r(e.test):""}; ${e.update?r(e.update):""}) ${n(e.body)}`;case"ForOfStmt":return`for (${`${e.left.declKind} ${e.left.name}`} of ${r(e.right)}) ${n(e.body)}`;case"ForInStmt":return`for (${`${e.left.declKind} ${e.left.name}`} in ${r(e.right)}) ${n(e.body)}`;case"Block":return t(e);case"ReturnStmt":return null===e.expr?"return;":`return ${r(e.expr)};`;case"ExprStmt":return`${r(e.expr)};`;default:throw new Error("Unknown stmt kind: "+e.kind)}}function t(e){return"{\n"+e.statements.map(e=>n(e)).filter(Boolean).map(e=>"  "+e).join("\n")+"\n}"}function r(e){switch(e.kind){case"NumberLiteral":return String(e.value);case"StringLiteral":return`"${e.value}"`;case"BoolLiteral":return e.value?"true":"false";case"Identifier":return e.name;case"BinaryExpr":return`${r(e.left)} ${e.op} ${r(e.right)}`;case"CallExpr":return`${r(e.callee)}(${e.args.map(r).join(", ")})`;case"MemberExpr":return`${r(e.object)}.${e.property}`;case"IndexExpr":return`${r(e.object)}[${r(e.index)}]`;case"ArrowFunction":{const n=1===e.params.length?e.params[0]:`(${e.params.join(", ")})`;return"Block"===e.body.kind?`${n} => ${t(e.body)}`:`${n} => ${r(e.body)}`}case"ArrayLiteral":return"["+e.elements.map(r).join(", ")+"]";case"UpdateExpr":return e.prefix?`${e.operator}${r(e.argument)}`:`${r(e.argument)}${e.operator}`;default:throw new Error("Unknown expr kind: "+e.kind)}}return e.body.map(n).filter(Boolean).join("\n")}export function transpile(e){const n=parse(tokenizeTS(e)),{errors:t}=typeCheck(n,e);if(t.length>0){console.log("\n=== TYPE ERRORS ===");const n=e.split(/\r?\n/);for(const r of t){const{msg:t,pos:o}=r;let i=1,p=1;for(let n=0;n<e.length&&n!==o;n++)"\n"===e[n]?(i++,p=1):p++;const u=n[i-1]||"";console.log(`\nâ€¢ ${t}`),console.log(`   ${i} | ${u}`),console.log("     | "+" ".repeat(p-1)+"^")}throw new Error("Type checking failed")}console.log("\nNo type errors.");return emitJS(n)}